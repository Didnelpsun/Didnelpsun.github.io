---
layout: post
title:  "应用"
date:   2022-03-22 16:25:09 +0800
categories: notes redis basic
tags: Redis 基础
excerpt: "应用"
---

## 缓存穿透

### &emsp;缓存穿透概念

数据库将缓存数据存放在Redis中。

key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，从而会转向查询数据库，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户ID获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞对数据库不断进行非正常访问进行攻击可能压垮数据库。

一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

### &emsp;缓存穿透解决

1. 对空值缓存∶如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。这样访问结果不存在时只能访问到缓存中的结果，不会进入数据库查询。是一个临时方案。
2. 设置可访问的名单（白名单）：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。效率较低。
3. 采用布隆过滤器∶布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避兔了对底层存储系统的查询压力。
4. 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。

&emsp;

## 缓存击穿

### &emsp;缓存击穿概念

key对应的数据存在，但在Redis中过期（没有缓存更新），此时若有大量并发请求过来，Redis正常运行，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，但是这个时候这个数据还没有缓存到Redis，对于这个数据的大并发的请求可能会瞬间把后端数据库压垮。从而导致缓存无效。

### &emsp;缓存击穿解决方案

1. 预先设置热门数据：在Redis高峰访问之前，把一些热门数据提前存入到Redis里面，加大这些热门数据key的时长。
2. 实时调整∶现场监控哪些数据热门，实时调整key的过期时长。
3. 使用锁：效率较低。
   1. 在缓存失效的时候（判断拿出来的值为空），不是立即去load db加载数据库数据。
   2. 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。
   3. 当操作返回成功时证明没有人访问数据库，进行load db，并回设缓存，删除mutex key。
   4. 当操作返回失败时证明有线程在load db，将当前线程睡眠一段时间后重新get缓存。

&emsp;

## 缓存雪崩

### &emsp;缓存雪崩概念

key对应的数据存在，但在Redis中大量集中都过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端数据库压垮。

缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key。

### &emsp;缓存雪崩解决

1. 构建多级缓存架构：nginx缓存+redis缓存+其他缓存（ehcache等）。
2. 使用锁或队列：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。
3. 设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。
4. 将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

&emsp;

## 分布式锁

### &emsp;分布式锁概念

随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨VM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题。

分布式锁主流的实现方案：

1. 基于数据库实现分布式锁。
2. 基于缓存（Redis等）。
3. 基于ZooKeeper。

每一种分布式锁解决方案都有各自的优缺点：Redis性能最高。Zookeeper最可靠。

### &emsp;Redis实现

Redis的命令setnx设置键名的同时对键名加锁，使用del命令删除键的同时释放锁。避免锁一直不释放，设置key的过期时间自动释放：

+ `set 键名 键值 ex 过期时间`，等同于`setex 键名 国家时间 键值`，单位为秒。
+ `set 键名 键值 px 过期时间`，等同于`psetex 键名 国家时间 键值`，单位为毫秒。
+ `set 键名 键值 nx`，等同于`setnx 键名 键值`，只有键不存在时才能对键进行操作。
+ `set 键名 键值 xx`，等同于`setxx 键名 键值`，只有键存在时才能对键进行操作。
+ `set 键名 键值 nx ex 过期时间`，同时上锁并设置过期时间。避免上锁后无法设置过期时间。

### &emsp;Java实现

类似于PV操作，设置一个同步锁mutex，如果存在这个锁就代表其他服务对数据操作就等待，否则进行操作。

```java
public void testLock () {
    // 获取锁，等价于setne
    Boolean lock = redisTemplate.opsForValue().setIfAbsent("lock"，"1", 2, TimeUnit.SECONDS);
    // 设置成功就代表获取锁成功、查询num的值
    if(lock) {
        Object value = redisTemplate.opsForValue().get("num");
        // 判断num为空return
        if(StringUtils.isEmpty(value)) {
            // 通过del释放锁
            redisTemplate.delete("lock");
            return;
        }
        // 有值就转成成int
        int num = Integer.parseInt(value+"");
        // 把redis的num加1
        redisTemplate.opsForValue(.set("num"，++num);
        // 通过del释放锁
        redisTemplate.delete("lock");
    } else {
        // 获取锁失败，就重新获取
        try {
            Thread.sleep(100);
            testLock();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

如果有多个锁，需要给每个锁进行区分，可以使用uuid作为lock的值，在删除锁时对锁的值进行判断，如果是当前方法的锁就删除。

由于Redis不具备原子性，锁操作分为四步：上锁，操作，判断锁，释放锁。如果某个方法A已经判断了uuid是要删的锁，正要删除当前的lock锁，这个锁突然过期了，其他方法B也可以操作lock，并将lock赋值为它自己的uuid，而此时A对lock进行删除，就删除了B的锁。此时可以使用Lua脚本支持原子操作（集群不支持）。
