---
layout: post
title:  "数据类型"
date:   2022-03-17 20:36:00 +0800
categories: notes redis basic
tags: Redis 基础 数据
excerpt: "数据类型"
---

Redis有五种常用的数据类型。

## 常用操作命令

### &emsp;库操作

+ `select 库编号`：来切换库。
+ `dbsize`：查看当前数据库的key数量。
+ `flushdb`：清空当前库。
+ `flushall`：清空所有库。

### &emsp;键操作

+ `keys *`：查看当前库所有key。
+ `exists 键名`：查看键是否存在。
+ `type 键名`：查看键的类型。
+ `del 键名`：删除键。
+ `unlink 键名`：根据value选择非阻塞删除，仅将键从keyspace元数据中删除，真正的删除会在后续异步操作。
+ `expire 键名 数字`：为给定的键设置过期时间，单位为秒。
+ `ttl 键名`：查看还有多少秒过期，-1表示永不过期，-2表示已过期。

## &emsp;控制台操作

+ `clear`：清空控制台。

## 字符串

即String类型。

一个key对应一个value，是二进制安全的，表示String类型可以包含任何数据，比如JPG图片以及序列化对象。字符串的值最大为512M。

### &emsp;字符串操作命令

+ `set 键名 键值`：来添加键。如果键名不存在是添加，如果键名存在是更新。
+ `get 键名`：获取键值。
+ `append 键名 键值`：将键值追加到原来键值的末尾。返回值为该键值追加后的整体长度。若不存在则会新建键。
+ `strlen 键名`：获得值的长度。
+ `setnx 键名 键值`：只有键不存在时才能新增键并复制，否则不能更新。
+ `mset 键名1 键值1 键名2 键值2 ...`：同时设置一个或多个键值对。
+ `mget 键名1 键值1 键名2 键值2 ...`：同时获取一个或多个键值对。
+ `msetnx 键名1 键值1 键名2 键值2 ...`：同时设置一个或多个键值对，当且仅当所有键名都不存在。
+ `getrange 键名 起始位置 结束位置`：获取一定索引范围的字符串值，类似substring，前后索引的值都包含。索引从0开始。
+ `setrange 键名 起始位置 键值`：用键值覆写从起始位置开始的字符串值。
+ `setex 键名 过期时间 键值`：设置键值的同时设置过期时间，单位为秒。
+ `getset 键名 键值`：设置键名所对应的新键值，并获得原来的键值。
+ `incr 键名`：将键中存储的数字值自增1，只对数字值有效，否则报错ERR value is not an integer or out of range。如果值为空，则将这个值设为1。
+ `decr 键名`：将键中存储的数字值自减1，只对数字值有效，否则报错ERR value is not an integer or out of range。如果值为空，则将这个值设为-1。
+ `incrby 键名 步长`：将键中保存的数字值加上步长。
+ `decrby 键名 步长`：将键中保存的数字值减去步长。

### &emsp;原子操作

Redis的incr、decr对存储在键中的数值进行原子的加减操作。所谓的原子操作不同于SQL的原子性，是指不会被线程调度context switch机制打断的操作，这种操作一旦开始就会一直运行到结束。

在单线程中，能够在单条指令中完成的操作都可以认为是原子操作，因为中断机制只能发生在指令之间。

在多线程中，不能被其他进程或线程打断的操作就是原子操作。

Redis单命令的原子性主要是因为Redis的单线程实现。

而如果Java是使用多线程实现的，所以i++这个命令就不符合原子性，如果假设i=0，Java两个线程A和B分别对i进行++100次，i的值会是多少？

首先i的值一定不会是一个具体值，因为线程AB的每次自增操作的顺序都是不确定的，所以只能确定i的一个范围。且i是被线程A和线程B共享的变量。

i++具体是怎么操作的呢？i作为局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，会把其对象本身存储在堆，而把这个对象的引用（指针）存储在栈。i是一个整形的局部变量，所以i应该保存在栈中。首先对i取出值，然后对这个值加一，然后再把值赋给i，一共三步。

最大值很好确定，就比如线程A先对i++一次性进行100次，线程B再对i++一次性进行100次，则i一共被++了两个100次，所以i就应该是200。

难点就是最小值如何确定：首先线程B抢到线权，开始对i取值，取到初始值0，还没开始++时线程A抢到了线权（线程B还要进行自增和赋值两步）；线程A此时也对i取值，取到i初始值为0，i一直被加到99，还差最后一次++；线程B又抢回线权，开始剩下的两步，进行++操作，由于线程B之前已经取到了i的值为0，0这个值在线程B的寄存器中，所以线程B是不会管i的值现在是多少的，将i从0加到1完成了一次自增，线程A中i=99就相当于被覆盖了；此时线程A只能再加1次了，线程B还能加99次；线程A抢回线权，取值为1，还没开始++时，又被线程B抢到线权（线程A还需要进行自增和赋值两步）；在B线程中i一直加到100结束，线程A抢回线权，由于已经取值i为1，1这个值在线程A的寄存器中，所以不会管i现在的值是多少，i+1=2，再赋值操作，将i赋值为2；线程A线程B都各自加了100次，最后i就是2。

所以从这个例子就能看出来为什么多线程需要原子性操作，要将自增的三步合成到一起保证数据不会错乱。

### &emsp;数值类型

Redis提供对字符串数字类型的操作方法，但是为什么不提供数值类型而只提供字符串类型？

首先我们必须去查看Redis内部是如何处理字符串类型的。

对于Redis的常用五种数据类型（String、Hash、List、Set、Zset），每种数据类型都提供了**最少两种**内部的编码格式，而且每个数据类型内部编码方式的选择，对用户是完全透明的，Redis会根据数据量自适应地选择较优化的内部编码格式。如果想查看某个键的内部编码格式，可以使用`object encoding 键名`指令来进行查看。

字符串有三种内部编码方式，Redis会自动选择：

+ int编码：保存long型的64位有符号整数。
+ embstr编码：保存长度小于44字节的字符串。内存是连续的。
+ raw编码：保存长度大于44字节的字符串。内存是不连续的。

Redis中String底层数据结构为C语言结构体定义的简单动态字符串SDS，内部实现类似Java的ArrayList，采用预分配冗余空间的方式来减少内存分配的频繁变化。当字符串小于1M时，扩容都是加倍现有空间，但是字符串超过1M时，每次扩容都只会增加1M空间。

另外Redis为整数0到9999预先分配10000个对象，即Redi 预先已建立好的共享redisObject对象。如果键的值在0到9999之间，Redis将使这些键共享该值，即指向这些预分配对象的指针，而不是为这些键创建新对象。

所以在底层中字符串是存在数值类型的。

参考<https://zhuanlan.zhihu.com/p/360169325>。

&emsp;

## 列表

即List类型。

一个键对应多个值，是简单的字符串列表，按照插入顺序进行排序。可以添加元素到表头也可以添加到表尾。所以List类型的底层实现是一个双向列表，所以对两端的操作性能会较好，对使用索引下标操作中间节点的性能会较差。

字符串列表本质就是一个队列，左边为队列头，右边为队列尾。

### &emsp;列表操作命令

+ `lpush/rpush 键名 键值1 键值2 ...`：从列表的左边/右边推入一个或多个值。
+ `lpop/rpop 键名 键值1 键值2 ...`：从列表的左边/右边弹出一个或多个值。如果值全部被弹出，则这个键名会无效。
+ `rpoplpush 键名1 键名2`：用键名1的列表右边弹出一个值，推入到键名2列表的左边。
+ `lindex 键名 索引值`：从左到右按照索引下标获得元素。
+ `lrange 键名 开始位置 结束位置`：按照索引下标从左到右获取元素。0为左边第一个，-1为右边第一个，也是最后一个。
+ `llen 键名`：获得列表长度。
+ `linsert 键名 before/after 键值 新键值`：在键值的前面/后面插入新键值。如果找到多个键值，那么会在第一个键值前后操作。
+ `lrem 键名 删除个数 键值`：从列表左边删除对应删除个数的键值。返回值为删除的个数，如果找不到删除值就会返回0，如果要删除个数大于原有删除值个数则只返回剩下的删除值个数。
+ `lset 键名 索引 键值`：将列表下标为对应索引的值替换为新的键值。

### &emsp;列表底层实现

List类型的底层实现是快速列表QuickList。首先在列表元素较少的情况下会使用连续内存存储，结构为ZipList压缩列表，所有的元素都会紧挨在一起。只有数据量较多时才会将多个ZipList使用指针链接在一起变为QuickList结构，使用`obejct encoding 键名`也可以判断。

普通的链表需要的附加指针空间较大，当数据量小时较浪费空间，所以当数据量小时不使用链表结构而使用ZipList存储。

&emsp;

## 集合

即Set类型。

Set和List也是一个列表的功能，但是Set是自动排重的，Set里面的元素是不重复且无序的。提供判断某个成员是否在集合内的接口。

### &emsp;集合基本操作

+ `sadd 键名 键值1 键值2 ...`：将一个或多个值加入倒集合中，如果有重复的成员会被忽略。
+ `smembers 键名`：取出该集合的所有值。
+ `sismember 键名 键值`：判断集合中是否存在该值的成员，如果存在就返回1，不存在就返回0。
+ `scard 键名`：返回该集合的成员个数。
+ `srem 键名 键值1 键值2 ...`：删除集合中的某些元素。
+ `spop 键名`：随机从集合中取出一个值。
+ `srandmember 键名 取值个数`：随机从集合中取出多个成员值，但是不会从集合中删除。取值个数可以是正数也可以是负数。如果取值个数是正数，那么取出的值不会重复，取值个数如果超过集合中的成员个数会将数据全部取出，数量为成员总数；如果取值个数为负数，那么取出的值会重复，取值个数按其绝对值来取值，取值个数如果超过集合中的成员个数会直接按照其绝对值来取，不会受成员总数的限制。
+ `smove 源集合名 目的集合名 键值`：从源集合中找到对应键值移动到目的集合中。
+ `sinter 键名1 键名2`：返回两个集合的交集。
+ `sunion 键名1 键名2`：返回两个集合的并集。
+ `sdiff 键名1 键名2`：返回两个集合的差集（在集合1中不在集合2中）。
+ `lindex 键名 索引值`：从左到右按照索引下标获得元素。
+ `lrange 键名 开始位置 结束位置`：按照索引下标从左到右获取元素。0为左边第一个，-1为右边第一个，也是最后一个。
+ `llen 键名`：获得列表长度。
+ `linsert 键名 before/after 键值 新键值`：在键值的前面/后面插入新键值。如果找到多个键值，那么会在第一个键值前后操作。
+ `lrem 键名 删除个数 键值`：从列表左边删除对应删除个数的键值。返回值为删除的个数，如果找不到删除值就会返回0，如果要删除个数大于原有删除值个数则只返回剩下的删除值个数。
+ `lset 键名 索引 键值`：将列表下标为对应索引的值替换为新的键值。

### &emsp;集合底层实现

Set类型的底层实现是Dict字典，实际上为一个值为null的哈希表，所以添加、删除、查询的复杂度都是$O(1)$。

&emsp;

## 哈希

即Hash类型。

是一个键值对的集合，是字符串类型的映射表，适合存储对象，类似Java的`Hash<String, Object>`。

Hash类型将数据分为key和hash两个部分，其中hash又分为filed和value两个部分。如key为user1，hash为{name:金, age:22}，其中name和age为filed，金和22为value。

### &emsp;哈希基本操作

+ `hset 键名 键域 键值`：给键中的域赋值。（hset后来已经可以像hmset一样给多个域赋值，hmset部分地方已经弃用）
+ `hget 键名 键域`：向键中的域取值。
+ `hmset 键名 键域1 键值1 键域2 键值2 ...`：批量给一个键中的域赋值。
+ `hexists 键名 键域`：查看键名指定键域是否存在。
+ `hkeys 键名`：列出该键名的所有键域。
+ `hvals 键名`：列出该键名的所有键值。
+ `hincrby 键名 键域 步长`：为键名指定键域的值添加步长（如果步长为负数则是减去）
+ `hsetnx 键名 键域 键值`：给键中的域赋值，当且仅当键域不存在。

### &emsp;哈希底层实现

Hash类型的底层实现有两种，一种是ZipList压缩列表，一种是HashTable哈希表。当键域与键值的长度较短且个数较少时使用压缩列表，否则使用哈希表。

&emsp;

## 有序集合

即Zset/Sorted Set类型。

与Set不同的是Zset没有重复元素。有序集合的每个成员都关联了一个评分Score，评分用来升序排列Zset中的成员。评分值可以是重复的。

由于元素是有序的，所以可以根据评分和次序来获取一定范围内的元素，且访问有序集合中间的元素也是较快的。

### &emsp;有序集合基本操作

+ `zadd 键名 评分1 键值1 评分2 键值2 ...`：将一个或多个键值和评分加入键中，如果不存在键值则是添加，若存在则是更新。返回值为添加成功的数量，如果都是修改则返回0。如果多个值的评分一样，则后插入的值索引较小（即新插入数据默认评分高于旧插入数据默认评分）。
+ `zrange 键名 开始索引 结束索引`：返回下标在开始索引和结束索引之间的元素，前后索引对应的值都包含，返回顺序是倒序。如果结束索引大于索引最大值且把后面的都返回，如果开始索引小于0则将负数索引作为倒数个数和结束索引一起返回。如一共五个值索引值为0到4，-2到2就是倒数第二个到正数第三个，就是正数第三个。
+ `zrange 键名 开始索引 结束索引 withscores`：返回下标在开始索引和结束索引之间的元素并返回评分。
+ `zrangebyscore 键名 评分最小值 评分最大值`：从键中取出评分在最小值和最大值之间的键值，前后都包含，并按升序排列。
+ `zrangebyscore 键名 评分最小值 评分最大值 withscores`：从键中取出评分在最小值和最大值之间的键值以及对应的评分，并按升序排列，前后都包含。
+ `zrevrangebyscore 键名 评分最小值 评分最大值`：从键中取出评分在最小值和最大值之间的键值，前后都包含，并按降序排列。
+ `zrangebyscore 键名 评分最小值 评分最大值 withscores`：从键中取出评分在最小值和最大值之间的键值以及对应的评分，并按降序排列，前后都包含。
+ `zincrby 键名 增量 键值`：为键中指定键值的评分加上增量。
+ `zrem 键名 键值`：删除键中指定键值的元素。
+ `zcount 键名 评分最小值 评分最大值`：统计键下分数区间内的元素个数。
+ `zrank 键名 键值`：返回该键值在键中的排名，从0开始。

### &emsp;有序集合底层实现

Zset等价于Java的`Map<String, Double>`，可以给每一个元素的value都赋予一个权重score，又类似于`TreeSet`，内部的元素按照权重score进行排序，可以得到每个元素的名次，也可以通过score的返回获取元素的列表。

Zset的底层使用了两个数据结构：

1. 哈希表。作用就是关联元素value和权重score，哈希表的field为value，哈希表的value为score，保障元素value的唯一性，可以通过元素value找到对应的score值。
2. 跳跃表。作用是使用权重score给元素value进行排序，根据score的范围获取元素列表。

&emsp;

## 字符流

即Stream类型。

是Redis5的新类型，使用Stream类型可以很好地完成消息队列功能。之前我们都是用Redis里面的List类型来模拟消息队列完成简单的队列功能，但是存在很多弊端。Stream能比List类型更好的模拟消息队列，但是仍比不上真正的消息对象MQ，只能说是低配的Kafka。

&emsp;

## JSON

即ReJSON类型。
