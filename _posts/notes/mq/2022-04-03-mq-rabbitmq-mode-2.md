---
layout: post
title:  "RabbitMQ交换模式"
date:   2022-04-03 22:15:52 +0800
categories: notes mq rabbitmq
tags: MQ RabbitMQ 模式
excerpt: "RabbitMQ模式（下）"
---

## 交换机

### &emsp;相关概念

#### &emsp;&emsp;交换机定义

RabbitMQ消息传递模型的核心思想是生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中，生产者只负责生产而不关心传输。

相反，生产者只能将消息发送到交换机，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就由交换机的类型来决定。

#### &emsp;&emsp;交换机类型

直接direct路由模式、主题topic主题发布模式、标题headers头模式（基本上不使用了）、扇出fanout发布订阅模式。

之前没有设置交换机，只传入一个空串，这就是无名类型的交换机，使用默认交换。

#### &emsp;&emsp;运行模式

通过交换机能实现其他三种模式：发布订阅模式、路由模式、主题模式。

### &emsp;临时队列

即没有持久化的队列，打开RabbitMQ控制台查看Queues时查看队列，如果Features不显示D则表示临时队列。

每当我们连接到RabbitMQ时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。

不指定队列名称来创建临时队列的方式：`String queueName = channel.queueDeclare().getQueue()`，名字为随机字符串。此时队列的Features显示AD自动删除和Exd自动命名。

### &emsp;绑定

即交换机与队列之间的对应关系，告诉我们该交换机与哪个队列具有绑定关系，交换机的消息可以派发给哪个队列。

通过RoutingKey绑定路由确定每个路由的处理方式。

&emsp;

## 发布订阅模式

即Fanout扇出。将接受到的所有消息广播到其已知的所有队列中。与之前不使用交换机的发布订阅模式不同的时，所有消费者只能对消息进行统一的操作，而交换机下的发布订阅模式能根据不同的路由对消费者进行差别处理。

这里定义两个消费者对同一个消息进行不同的处理，以及一个生产者发送同样的消息。

定义一个publish_subscribe模块，添加utils依赖。并在Property中添加一个常量`public static final String EXCHANGE = "exchange";`。

队列和交换机在生产者和消费者里都可以声明，可以只声明一次，但是由于队列和交换机只有声明了才能使用，所以必须声明的实例先启动，为了不用区分先启动消费者还是先启动生产者，我生产者和消费者都声明一次。

&emsp;

## 路由模式

对于工作队列模式，所有接受了指定队列的消费者都会接受到该消息，使用的广播模式。如果想不同的消费者收到不同的消息必须使用不同的生产者与队列。而如果我们想使用同一个生产者，让不同的消费者接受不同的信息，则可以使用路由模式，让一个生产者拥有多个队列。

定义一个route模块，添加utils依赖。

&emsp;

## 主题模式

定义一个topic模块，添加utils依赖。

[RabbitMQ模式：MQ/rabbitmq_mode](https://github.com/Didnelpsun/MQ/tree/main/rabbitmq_mode)。
