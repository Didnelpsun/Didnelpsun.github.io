---
layout: post
title:  "RabbitMQ高级队列"
date:   2022-04-07 17:39:47 +0800
categories: notes mq rabbitmq
tags: MQ RabbitMQ 队列 高级
excerpt: "RabbitMQ高级队列"
---

## 幂等性

### &emsp;概念

即非原子性导致重复消费问题。

#### &emsp;&emsp;数据重复消费

用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。

#### &emsp;&emsp;消息重复消费

消费者在消费MQ中的消息时，MQ已把消息发送给消费者，消费者在给MQ返回ack时网络中断，故MQ未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息。

### &emsp;解决方式

#### &emsp;&emsp;生产者

MQ消费者的幂等性的解决一般让生产者给每条消息设置全局ID或者写个唯一标识比如时间戳或者UUID，或者订单消费者消费MQ中的消息也可利用MQ的该ID来判断，或者可按自己的规则生成一个全局唯一ID，每次消费消息时用该ID先判断该消息是否已消费过。

当消息过期后删除消费者缓存的ID信息。但是这样如果遇到搞并发的情况会短时间在缓存中存入大量的数据。

#### &emsp;&emsp;消费者

在海量订单生成的业务高峰期，生产端有可能就会重复发送了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息。业界主流的幂等性有两种操作：

+ 唯一ID+指纹码机制：
  + 指纹码是我们的一些规则或者时间戳加别的服务给到的唯一信息码，它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性。
  + 然后就利用查询语句进行判断这个ID是否存在数据库中。
  + 优势就是实现简单就一个拼接，然后查询判断是否重复。
  + 劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能，但也不是我们最推荐的方式。
+ 利用NoSQL的类原子性去实现：
  + 如Redis执行setnx命令只新增数据，天然具有幂等性，从而实现不重复消费。
  + 但是缺乏可重入性与尝试机制，集群模式下缺乏主从一致性，所以一般使用reddison的分布式锁。

&emsp;

## 优先级队列

### &emsp;优先使用场景

对消费者进行分优先级，优先级高的消息先发送。

在我们系统中有一个订单催付的场景，我们的客户在天猫下的订单，淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用Redis来存放的定时轮询，大家都知道Redis只能用List做一个简简单单的消息队列，并不能实现一个优先级的场景，所以订单量大了后采用RabbitMQ进行改造和优化，如果发现是大客户的订单给一个相对比较高的优先级，否则就是默认优先级。

默认队列是先进先出的（如TTL实现延迟队列时也是先进先出），而优先级队列是按优先级出队，优先级0到255，越大优先级越高。如果不设置优先级则优先级最低。

### &emsp;设置优先级队列

#### &emsp;&emsp;控制台

直接选择Queues部分，添加Queue，然后Arguments填写x-max-priority表示这是个优先级队列，表示最大的优先级数为多少，建议取较小的数，如10。添加后队列的Features显示Pri表示含有优先级。

#### &emsp;&emsp;代码

要让队列实现优先级需要做的事情有如下事情：

+ 队列需要设置为优先级队列，消息需要设置消息的优先级。
+ 消费者需要等待消息已经发送到队列中才去消费消息，（即先运行生产者结束生产再运行消费者）因为这样才有机会对队列中存在的消息进行排序。

队列设置最大优先级：

```java
// Spring通过信道
Map<String, Object> arguments = new HashMap();
arguments.put("x-max-priority", 10);
channel.queueDeclare("test", false, false, false, arguments);

// SpringBoot通过构造器
// 通过传入参数
Map<String, Object> arguments = new HashMap();
arguments.put("x-max-priority", 10);
QueueBuilder.nonDurable(queueName).withArguments(arguments).build();
// 通过方法
QueueBuilder.nonDurable(queueName).maxPriority(10).build();
```

消息设置优先级：

```java
rabbitTemplate.convertAndSend(exchangeName, routingKey, new Message(message.getBytes(StandardCharsets.UTF_8), new AMQP.BasicProperties().builder().priority(4).build()), data);
```

如果要运行测试可以使用Spring来测试而不是用SpringBoot，因为Spring的消费者和生产者是分开编写的，测试函数也是分开的，所以可以独自运行，而SpringBoot是在一起实例化的，生产者和消费者是一起运行的无法让消费者等待生产完成，所以消费者会一个个消费生产者的消息。

&emsp;

## 惰性队列

### &emsp;惰性使用场景

RabbitMQ从3.6.0版本开始引入了惰性队列的概念。惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。当消费者由于各种各样的原因（比如消费者下线、宕机亦或者是由于维护而关闭等）而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了。

默认情况下，当生产者将消息发送到RabbitMQ的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者。即使是持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当RabbitMQ需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息。虽然RabbitMQ的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。

### &emsp;模式

队列具备两种模式: default和lazy。

默认的为default模式，在3.6.0之前的版本无需做任何变更。

lazy模式即为惰性队列的模式，可以通过调用`channel.queueDeclare()`方法的时候在参数中设置（通过"x-queue-mode"参数来设置队列的模式，取值为"default"和"lazy"），也可以通过`Policy`的方式设置，如果一个队列同时使用这两种方式设置的话，那么Policy的方式具备更高的优先级。

如果要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的。

```java
Map<String, Object> args = new HashMap<String, Object>();args.put(""x-queue-mode" , " lazy");
channel.queueDeclare("myqueue" , false, false, false, args);
```
