---
layout: post
title:  "java基础5"
date:   2019-09-18 12:26:56 +0800
categories: notes java base
tags: java 基础 5
excerpt: "字符串（string类）"
---

## 字符串

Java中字符串以`String`类的实例来处理。可以通过`java.lang`包中的`String`类创建字符串对象。

### &emsp;1. 声明

字符串必须在双引号中，如："你好"，"a"  
<font color="aqua">格式：</font>

`String 字符串变量名;`  

字符串必须声明才能使用，如果最开始不知道其值，可以赋为空字符串。

### &emsp;2 创建与赋值

#### &emsp;&emsp;2.1 使用字符数组构造

<font color="aqua">格式：</font>

`String 变量名=new String(字符数组名);`  

如：

```java
char a[] = {'a','b','c'};
String s = new String(a);
```

<font color="aqua">格式：</font>

`String 变量名= new String(字符数组名,开始截取字符串位置，截取字符串长度);`  

可以提取字符数组的一部分。

#### &emsp;&emsp;2.2 使用字符串常量构造

<font color="aqua">格式：</font>

`String 变量名=new String(字符串常量);`  

如：  
`String s = new String("nmsl");`

#### &emsp;&emsp;2.3 引用字符串常量

<font color="aqua">格式：</font>

```java
String 变量名;  
变量名=字符串常量;  
```

如：  

```java
String s1;
s1="hello world";
```

值得注意的是如果将多个变量都引用同一个字符串常量，那实际上他们是一样的，因为他们都指向同一个实体。

### &emsp;3. 字符串连接

#### &emsp;&emsp;3.1 连接多字符串

使用+连接多个字符串。  
且如果一个字符串太长，可以将字符串分开，换行再加上+。

#### &emsp;&emsp;3.2 连接其他数据类型

同样使用+号连接，会将不同类型的变量统一转换为字符串，因为会自动调用`toString()`方法。  
如果我们想在输出的时候先对变量操作，可以使用()将相应的变量包裹，因为()的优先级最高。  

### &emsp;4. 获取字符串信息

#### &emsp;&emsp;4.1 获取字符串长度（length()）

<font color="aqua">格式：</font>

`字符串变量名.length();`

#### &emsp;&emsp;4.2 字符串查找（indexOf()、lastIndexOf()）

<font color="aqua">格式：</font>

`目标字符串.indexOf(搜索字符串)`  

返回搜索的字符或字符串首次出现的位置。如果没有搜索到就返回-1。  

<font color="aqua">格式：</font>

`目标字符串.lastIndexOf(搜索字符串)`  

返回搜索的字符或字符串最后一次出现的位置。如果没有搜索到就返回-1。  

如果搜索字符串是空字符串，那么返回就是字符串长度。  

#### &emsp;&emsp;4.3 获取指定索引位置的字符（charAt()）

<font color="aqua">格式：</font>

`目标字符串.charAt(索引值);`

### &emsp;5. 字符串操作

#### &emsp;&emsp;5.1 截取字符串（substring()）

<font color="aqua">格式：</font>

`目标.substring(开始截取索引值)`  

返回从指定的索引值开始截取到结尾的子串。

<font color="orange">注意：</font>

字符串中空格占一个索引位置。  

<font color="aqua">格式：</font>

`目标.substring(开始截取索引值,结束索引值)`  

返回从指定的索引值开始截取到结束位置的子串。

#### &emsp;&emsp;5.2 去除空格（trim()）

<font color="aqua">格式：</font>

`目标字符串.trim()`  

返回字符串的副本，忽略前导空格和尾部空格。  

#### &emsp;&emsp;5.3 替换字符串（replace()）

<font color="aqua">格式：</font>

`目标字符串.replace(要替换的字符或字符串,用于替换原来字符串的内容)`  

返回的是一个新字符串，如果要替换的字符或字符串没有出现在目标字符串中，那返回原字符串。  
且替换是全局替换。

#### &emsp;&emsp;5.4 判断字符串开始结尾（startsWith()、endsWith()）

这两个方法是判断字符串是否以指定的内容开始或者结束，其返回值为`boolean`值。  

`startsWith()`判断当前字符串对象的前缀是否为参数指定的字符串。  

<font color="aqua">格式：</font>

`目标字符串.startsWith(前缀字符)`  

endsWith()判断当前字符串对象是否以参数指定的字符串结束。  

<font color="aqua">格式：</font>

`目标字符串.endsWith(后缀字符)`  

如：  

```java
String s1 = new String("24533");  
boolean b = s1.startsWith("24");  
```

#### &emsp;&emsp;5.5 判断字符串是否相等（equals()、equalslgnoreCase()）

对于字符串对象不能简单地使用==来比较，因为这样比较的是两个对象的地址，而这两个对象如果是不一样的，对象的地址是不同的。所以即使他们的值相等，那么返回的仍然是`false`。  

<font color="aqua">格式：</font>

`目标字符串1.equals(目标字符串2)`  

如果字符串具有相同的字符或者长度，就返回`true`。  

<font color="aqua">格式：</font>

`目标字符串1.equalsIgnoreCase(目标字符串2)`  

如果字符串具有相同的字符或者长度，就返回`true`。但是字符串不区分大小写。  

#### &emsp;&emsp;5.6 判断字符串顺序（compareTo()）

<font color="aqua">格式：</font>

`目标字符串1.compareTo(目标字符串2)`  

按字典顺序比较两个字符串，基于每个字符的Unicode值，如果目标字符串1位于目标字符串2前面，就返回一个负整数，若是在后面，就返回一个正整数，如果相等就返回0。

#### &emsp;&emsp; 5.7 大小写转换（toLowerCase()、toUpperCase()）

<font color="aqua">格式：</font>

`目标字符串.toLowerCase()`  

全部字母转为小写。  

<font color="aqua">格式：</font>

`目标字符串.toUpperCase()`  

全部字母转为大写。  
大小写转换时数字与非字符不受影响。  

#### &emsp;&emsp; 5.8 分割字符串（split()）

<font color="aqua">格式：</font>

`目标字符串.split(分隔符号或者正则表达式)`  

如果有多高分隔符，可使用\|隔开分割符。

<font color="aqua">格式：</font>

`目标字符串.split(分隔符号或者正则表达式,切割限定次数)`

```java
String str2="a&b&c";
String strs[]=str2.split("&");
   for(String str:strs){
System.out.println(str);
}
不会输出a,b,c,只有这样处理才可以：
String str2="a&b&c";
String strs[]=str2.split("\\u0024");
   for(String str:strs){
System.out.println(str);
}  
```

1. 如果用“.”作为分隔的话，必须是如下写法：`String.split("\\.")`,这样才能正确的分隔开，不能用`String.split(".")`;
2. 如果用“|”作为分隔的话，必须是如下写法：`String.split("\\|")`,这样才能正确的分隔开，不能用`String.split("|")`;
`.`和`|`都是转义字符，必须得加`\\`;

### &emsp;6. 字符串生成器（String-Builder类）

创建成功的字符串对象，长度是固定的，内容无法被改变，虽然使用+可以增长字符串，但是其实是返回一个新的`String`对象。如果是重复修改字符串会大量占用系统内存，所以增加了字符序列`String-Builder`类。该类在`java.lang.StringBuilder`的API。  

<font color="aqua">格式：</font>

`StringBuilder 对象名 = new StringBuilder("字符串初始值");`

#### &emsp;&emsp;6.1 append()

用于向字符串生成器追加内容，可以追加任何数据类型，如`int`、`boolean`、另一个字符串生成器等。  

<font color="aqua">格式：</font>

`字符串生成器名.append(内容);`  

#### &emsp;&emsp;6.2 insert()

用于向字符串生成器插入内容，可以插入任何数据类型，如`int`、`boolean`、另一个字符串生成器等。  

<font color="aqua">格式：</font>

`字符串生成器名.insert(目标索引值,内容);`

#### &emsp;&emsp;6.3 delete()

用于删除字符串生成器中的字符。  

<font color="aqua">格式：</font>

`字符串生成器名.delete(起始位置,结束位置);`  

不包含结束位置。  

#### &emsp;&emsp;6.4 toString()

将该对象转换为字符串输出。直接`字符串.string()`

### &emsp;7. 日期

#### &emsp;&emsp;7.1 Date类

`java.util`包提供了`Date`类来封装当前的日期和时间。`Date`类提供两个构造函数来实例化`Date`对象。

第一个构造函数使用当前日期和时间来初始化对象。  
`Date( )`  
第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。  
`Date(long millisec)`

常用方法：

1. `boolean after(Date date)`  
若当调用此方法的`Date`对象在指定日期之后返回`true`,否则返回`false`。
2. `boolean before(Date date)`  
若当调用此方法的`Date`对象在指定日期之前返回`true`,否则返回`false`。
3. `Object clone( )`  
返回此对象的副本。
4. `int compareTo(Date date)`  
比较当调用此方法的`Date`对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。
5. `int compareTo(Object obj)`  
若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出`ClassCastException`。
6. `boolean equals(Object date)`  
当调用此方法的`Date`对象和指定日期相等时候返回`true`,否则返回`false`。
7. `long getTime()`  
返回自1970年1月1日00:00:00GMT以来此`Date`对象表示的毫秒数。
8. `int hashCode()`  
 返回此对象的哈希码值。
9. `void setTime(long time)`
用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。
10. `String toString()`
把此`Date`对象转换为以下形式的`String`：`dow mon dd hh:mm:ss zzz yyyy`其中：`dow`是一周中的某一天(Sun, Mon, Tue, Wed, Thu, Fri, Sat)。

#### &emsp;&emsp;7.2 Calendar类

我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用`Calendar`类。  

`Calendar`类的功能要比`Date`类强大很多，而且在实现方式上也比`Date`类要复杂一些。

`Calendar`类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用`getInstance`方法创建即可。  

创建一个代表系统当前日期的`Calendar`对象  
`Calendar c = Calendar.getInstance();//默认是当前日期`
创建一个指定日期的`Calendar`对象
使用`Calendar`类代表特定的时间，需要首先创建一个`Calendar`的对象，然后再设定该对象中的年月日参数来完成。

```java
//创建一个代表2009年6月12日的Calendar对象
Calendar c1 = Calendar.getInstance();
c1.set(2009, 6 - 1, 12);
```

`Calendar`类对象字段类型
`Calendar`类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想

常量  
`Calendar.YEAR` 年份  
`Calendar.MONTH` 月份  
`Calendar.DATE` 日期  
`Calendar.DAY_OF_MONTH` 日期，和上面的字段意义完全相同  
`Calendar.HOUR` 12小时制的小时  
`Calendar.HOUR_OF_DAY` 24小时制的小时  
`Calendar.MINUTE` 分钟  
`Calendar.SECOND` 秒  
`Calendar.DAY_OF_WEEK` 星期几  

##### &emsp;&emsp;&emsp;7.2.1 set方法

如：
`Calendar c1 = Calendar.getInstance();`  
调用：  

```java
public final void set(int year,int month,int date)
c1.set(2009, 6 - 1, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12
```

利用字段类型设置  

如果只设定某个字段，例如日期的值，则可以使用如下set方法：

`public void set(int field,int value)`

1. 把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算  
   `c1.set(Calendar.DATE,10);`  

2. 把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算  
    `c1.set(Calendar.YEAR,2008);`

其他字段属性set的意义以此类推

##### &emsp;&emsp;&emsp;7.2.2 add方法

`Calendar c1 = Calendar.getInstance();`  
把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算

`c1.add(Calendar.DATE, 10);`  
把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算

`c1.add(Calendar.DATE, -10);`  
其他字段属性的add的意义以此类推

```java
Calendar c1 = Calendar.getInstance();
// 获得年份
int year = c1.get(Calendar.YEAR);
// 获得月份
int month = c1.get(Calendar.MONTH) + 1;
// 获得日期
int date = c1.get(Calendar.DATE);
// 获得小时
int hour = c1.get(Calendar.HOUR_OF_DAY);
// 获得分钟
int minute = c1.get(Calendar.MINUTE);
// 获得秒
int second = c1.get(Calendar.SECOND);
// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）
int day = c1.get(Calendar.DAY_OF_WEEK);
```

#### &emsp;&emsp;7.3 GregorianCalendar类

`Calendar`类实现了公历日历，`GregorianCalendar`是`Calendar`类的一个具体实现。

`Calendar`的`getInstance()`方法返回一个默认用当前的语言环境和时区初始化的`GregorianCalendar`对象。`GregorianCalendar`定义了两个字段：AD和BC。这是代表公历定义的两个时代。

构造方法：  

1. `GregorianCalendar()`  
在具有默认语言环境的默认时区内使用当前时间构造一个默认的 `GregorianCalendar`对象。  
2. `GregorianCalendar(int year, int month, int date)`  
在具有默认语言环境的默认时区内构造一个带有给定日期设置的`GregorianCalendar`。  
3. `GregorianCalendar(int year, int month, int date, int hour, int minute)`  
为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的。   GregorianCalendar。  
4. `GregorianCalendar(int year, int month, int date, int hour, int minute, int second)`  
  为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 `GregorianCalendar`。  
5. `GregorianCalendar(Locale aLocale)`  
在具有给定语言环境的默认时区内构造一个基于当前时间的`GregorianCalendar`。  
6. `GregorianCalendar(TimeZone zone)`  
在具有默认语言环境的给定时区内构造一个基于当前时间的`GregorianCalendar`。  
7. `GregorianCalendar(TimeZone zone, Locale aLocale)`  
 在具有给定语言环境的给定时区内构造一个基于当前时间的`GregorianCalendar`。  

常用方法：  

1. `void add(int field, int amount)`  
根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。
2. `protected void computeFields()`  
转换UTC毫秒值为时间域值
3. `protected void computeTime()`  
覆盖Calendar ，转换时间域值为UTC毫秒值
4. `boolean equals(Object obj)`  
比较此 GregorianCalendar 与指定的 Object。
5. `int get(int field)`  
获取指定字段的时间值
6. `int getActualMaximum(int field)`  
返回当前日期，给定字段的最大值
7. `int getActualMinimum(int field)`  
返回当前日期，给定字段的最小值
8. `int getGreatestMinimum(int field)`  
 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。
9. `Date getGregorianChange()`  
获得格里高利历的更改日期。
10. `int getLeastMaximum(int field)`  
返回此 GregorianCalendar 实例给定日历字段的最低的最大值
11. `int getMaximum(int field)`  
返回此 GregorianCalendar 实例的给定日历字段的最大值。
12. `Date getTime()`  
获取日历当前时间。
13. `long getTimeInMillis()`  
获取用长整型表示的日历的当前时间
14. `TimeZone getTimeZone()`  
获取时区。
15. `int getMinimum(int field)`  
返回给定字段的最小值。
16. `int hashCode()`  
重写hashCode.
17. `boolean isLeapYear(int year)`  
确定给定的年份是否为闰年。
18. `void roll(int field, boolean up)`  
在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。
19. `void set(int field, int value)`  
用给定的值设置时间字段。
20. `void set(int year, int month, int date)`  
设置年、月、日的值。
21. `void set(int year, int month, int date, int hour, int minute)`  
设置年、月、日、小时、分钟的值。
22. `void set(int year, int month, int date, int hour, int minute, int second)`  
设置年、月、日、小时、分钟、秒的值。
23. `void setGregorianChange(Date date)`  
`设置 GregorianCalendar 的更改日期。
24. `void setTime(Date date)`  
用给定的日期设置Calendar的当前时间。
25. `void setTimeInMillis(long millis)`  
用给定的long型毫秒数设置Calendar的当前时间。
26. `void setTimeZone(TimeZone value)`  
用给定时区值设置当前时区。
27. `String toString()`  
返回代表日历的字符串。

如：

```java
import java.util.*;
public class GregorianCalendarDemo {
   public static void main(String args[]) {
      String months[] = {
      "Jan", "Feb", "Mar", "Apr",
      "May", "Jun", "Jul", "Aug",
      "Sep", "Oct", "Nov", "Dec"};
      int year;
      // 初始化 Gregorian 日历
      // 使用当前时间和日期
      // 默认为本地时间和时区
      GregorianCalendar gcalendar = new GregorianCalendar();
      // 显示当前时间和日期的信息
      System.out.print("Date: ");
      System.out.print(months[gcalendar.get(Calendar.MONTH)]);
      System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");
      System.out.println(year = gcalendar.get(Calendar.YEAR));
      System.out.print("Time: ");
      System.out.print(gcalendar.get(Calendar.HOUR) + ":");
      System.out.print(gcalendar.get(Calendar.MINUTE) + ":");
      System.out.println(gcalendar.get(Calendar.SECOND));
      // 测试当前年份是否为闰年
      if(gcalendar.isLeapYear(year)) {
         System.out.println("当前年份是闰年");
      }
      else {
         System.out.println("当前年份不是闰年");
      }
   }
}

>>>>>
Date: Apr 22 2009
Time: 11:25:27
当前年份不是闰年
```

### &emsp;8. 格式化字符串

`String`类的静态`format()`方法用于创建格式化的字符串。  
可以和`println()`配合使用以实现`printf()`方法的作用。  

<font color="aqua">格式：</font>

`String.format(格式转换字符串，参数)`  

参数可以为0，如果参数数量超过了对应格式符的数量，多余的就自动省略。  

<font color="aqua">格式：</font>

`String.format(格式化应用的语言环境,格式转换字符串，参数)`  

一般省去语言环境的化就进行本地化，如果该参数为`null`，就不进行本地化。  

格式转换码一般以%开始。

#### &emsp;&emsp;8.1 日期时间字符串格式化

导入Date包:`import java.util.Date`  
然后需要创建Date对象然后对这个对象格式化然后输出。  

##### &emsp;&emsp;&emsp;8.1.1 format()函数

日期格式化转换码：  
%te：一个月的天数；  
%tb：语言环境下的月份简称；  
%tB：语言环境下的月份全称；  
%ta：语言环境下的星期几简称；
%tA：指定语言环境的星期几全称；  
%tc：包括全部日期和时间信息；  
%ty：二位年份；  
%tY:四位年份；  
%tj：一年中的第几天；  
%tm：月份；  
%td：一个月中的第几天；

如：  

```java
import java.util.Date;
public class Eval{
    public static void main(String[] args){
        Date date = new Date();
        String year = String.format("%Y",date);
        String month = String.format("%tB",date);
        String day = String.format("%td",date);
        System.out.println("今年："+year+"年");
        System.out.println("现在是"+month);
        System.out.println("今天是："+day+"号");
    }
}
```

时间格式转换码：  
%tI：2位数字的12的小时；  
%tH：2位数字的24的小时；  
%tl：1到2位数字的12的小时；  
%tk：1到2位的24的小时；  
%tM：2位数字的分钟；  
%tS：2位数字的秒数；  
%tL：3位数字的毫秒数；  
%tN：9位数字的微秒数；  
%tp：指定语言的上午下午标记；  
%tZ：相对于GMT RFC 82格式的数字时区偏移量；  
%ts：1970.1.1.00:00:00到现在的秒数；  
%tQ：1970.1.1.00:00:00到现在的秒数；  
获取时间方式是与获取日期一致的。

日期时间组合格式转换码：  
%tF：年-月-日 四位年份格式；  
%tD：月/日/年 两位年份格式；  
%tc：全部日期和时间信息；  
%tr：时：分：秒 PM/AM 12时制格式；  
%tT：时：分：秒 24时制格式；  
%tR：时：分 24时制格式；

##### &emsp;&emsp;&emsp;8.1.2 SimpleDateFormat类

`SimpleDateFormat`是一个以语言环境敏感的方式来格式化和分析日期的类。  `SimpleDateFormat`允许你选择任何用户自定义日期时间格式来运行。  

如：

```java
import  java.util.*;
import java.text.*;
public class DateDemo {
    public static void main(String args[]) {
    Date dNow = new Date( );
    SimpleDateFormat ft = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");
        System.out.println("当前时间为: " + ft.format(dNow));
   }
}
```

这一行代码确立了转换的格式，其中yyyy是完整的公元年，MM是月份，dd是日期，HH:mm:ss 是时、分、秒。

注意:有的格式大写，有的格式小写，例如MM是月份mm是分；HH是24小时制，而hh是12小时制。  
`>>>>>2018-09-06 10:16:34`

格式控制符：

字母|描述|示例  
:--:|:--|:--:
G|纪元标记|AD  
y|四位年份|2001  
M|月份|July or 07  
d|一个月的日期|10  
h|A.M./P.M. (1~12)格式小时|12  
H|一天中的小时 (0~23)|22  
m|分钟数|30  
s|秒数|55  
S|毫秒数 234  
E|星期几|Tuesday  
D|一年中的日子|360  
F|一个月中第几周的周几|2 (second Wed. in July)  
w|一年中第几周|40  
W|一个月中第几周|1  
a|A.M./P.M. 标记|PM  
k|一天中的小时(1~24)|24  
K| A.M./P.M. (0~11)格式小时|10  
z|时区 Eastern Standard Time|+8000  
'|文字定界符|Delimiter  
"|单引号|`  

##### &emsp;&emsp;&emsp;8.1.3 printf()函数

printf方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。  
c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007  
F "年-月-日"格式 2007-10-27  
D "月/日/年"格式 10/27/07  
r "HH:MM:SS PM"格式（12时制） 02:25:51 下午  
T "HH:MM:SS"格式（24时制） 14:28:16  
R "HH:MM"格式（24时制） 14:28  

如：

```java
import java.util.Date;
public class DateDemo {
  public static void main(String args[]) {
     // 初始化 Date 对象
     Date date = new Date();
    //c的使用  
    System.out.printf("全部日期和时间信息：%tc%n",date);
    //f的使用  
    System.out.printf("年-月-日格式：%tF%n",date);  
    //d的使用  
    System.out.printf("月/日/年格式：%tD%n",date);  
    //r的使用  
    System.out.printf("HH:MM:SS PM格式（12时制）：%tr%n",date);  
    //t的使用  
    System.out.printf("HH:MM:SS格式（24时制）：%tT%n",date);  
    //R的使用  
    System.out.printf("HH:MM格式（24时制）：%tR",date);  
  }
}
>>>>>
全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  
年-月-日格式：2012-09-10  
月/日/年格式：09/10/12  
HH:MM:SS PM格式（12时制）：10:43:36 上午  
HH:MM:SS格式（24时制）：10:43:36  
HH:MM格式（24时制）：10:43  
```

如果你需要重复提供日期，那么利用这种方式来格式化它的每一部分就有点复杂了。因此，可以利用一个格式化字符串指出要被格式化的参数的索引。

索引必须紧跟在%后面，而且必须以`$`结束。例如：

```java
import java.util.Date;
public class DateDemo {
   public static void main(String args[]) {
       // 初始化 Date 对象
       Date date = new Date();
       // 使用toString()显示日期和时间
       System.out.printf("%1$s %2$tB %2$td, %2$tY","Due date:", date);
   }
}
>>>>>
Due date: February 09, 2014
```

或者，你可以使用<标志。它表明先前被格式化的参数要被再次使用。例如：

```java
import java.util.Date;
public class DateDemo {
   public static void main(String args[]) {
       // 初始化 Date 对象
       Date date = new Date();  
       // 显示格式化时间
       System.out.printf("%s %tB %<te, %<tY","Due date:", date);
   }
}

>>>>>
Due date: February 09, 2014
```

定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如下所示：

```java
import java.util.*;
public class DateDemo {
   public static void main(String args[]) {
       Date date=new Date();
        //b的使用，月份简称  
        String str=String.format(Locale.US,"英文月份简称：%tb",date);
        System.out.println(str);
        System.out.printf("本地月份简称：%tb%n",date);  
        //B的使用，月份全称  
        str=String.format(Locale.US,"英文月份全称：%tB",date);  
        System.out.println(str);  
        System.out.printf("本地月份全称：%tB%n",date);  
        //a的使用，星期简称  
        str=String.format(Locale.US,"英文星期的简称：%ta",date);  
        System.out.println(str);  
        //A的使用，星期全称  
        System.out.printf("本地星期的简称：%tA%n",date);  
        //C的使用，年前两位  
        System.out.printf("年的前两位数字（不足两位前面补0）：%tC%n",date);  
        //y的使用，年后两位  
        System.out.printf("年的后两位数字（不足两位前面补0）：%ty%n",date);  
        //j的使用，一年的天数  
        System.out.printf("一年中的天数（即年的第几天）：%tj%n",date);  
        //m的使用，月份  
        System.out.printf("两位数字的月份（不足两位前面补0）：%tm%n",date);  
        //d的使用，日（二位，不够补零）  
        System.out.printf("两位数字的日（不足两位前面补0）：%td%n",date);  
        //e的使用，日（一位不补零）  
        System.out.printf("月份的日（前面不补0）：%te",date);  
   }
}
>>>>>
英文月份简称：May
本地月份简称：五月
英文月份全称：May
本地月份全称：五月
英文星期的简称：Thu
本地星期的简称：星期四
年的前两位数字（不足两位前面补0）：20
年的后两位数字（不足两位前面补0）：17
一年中的天数（即年的第几天）：124
两位数字的月份（不足两位前面补0）：05
两位数字的日（不足两位前面补0）：04
月份的日（前面不补0）：4
```

#### &emsp;&emsp;8.2 常规字符串格式化

%b、%B：转换为布尔类型；  

%h、%H：转换为散列码；  

%s、%S：转换为字符串类型；  

%c、%C：转换为字符类型；  

%d：转换为十进制整数；  

%o：转换为八进制整数；  

%x、%X：转换为十六进制整数；  

%e：转换为用计算机科学计数法表示的十进制数；  

%a：转换为带有效位数和指数的十六进制浮点值；  

%n：转换为行分隔符； %%：转换为%；

### &emsp;9. 正则表达式（regex类）

导入`regex`包:`import java.util.regex`  
`java.util.regex`包主要包括以下三个类：  

1. Pattern 类：  
pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

2. Matcher 类：
Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

3. PatternSyntaxException：
PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

#### &emsp;&emsp;9.1 常见匹配符号

`.` 匹配所有单个字符，除了换行符（Linux 中换行是 \n，Windows 中换行是 \r\n）  

`^regex` 正则必须匹配字符串开头  

`regex$` 正则必须匹配字符串结尾  

`[abc]` 复选集定义，匹配字母 a 或 b 或 c  

`[abc][vz]` 复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z  

`[^abc]` 当插入符 ^ 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c  

`[a-d1-7]` 范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1

`XZ` 匹配 X 后直接跟着 Z  

`X|Z` 匹配 X 或 Z  

<font color="orange">注意：</font>

`[jpg|png]` 代表匹配 j 或 p 或 g 或 p 或 n 或 g 中的任意一个字符。  

`(jpg|png)` 代表匹配 jpg 或 png。  

因为[]代表或，而()代表分组。

#### &emsp;&emsp;9.2 元字符

是一个预定义的字符。  

\d 匹配一个数字，是`[0-9]`的简写  

\D 匹配一个非数字，是`[^0-9]`的简写  

\s 匹配一个空格，是`[ \t\n\x0b\r\f]`的简写  

\S 匹配一个非空格  

\w 匹配一个单词字符（大小写字母、数字、下划线），是`[a-zA-Z_0-9]`的简写  

\W 匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 `[^\w]`  

#### &emsp;&emsp;9.3 限定符

限定符定义了一个元素可以发生的频率。  

`*` 匹配 >=0 个，是`{0,}`的简写。`X*`表示匹配零个或多个字母X，`.*`表示匹配任何字符串

`+` 匹配 >=1 个，是`{1,}`的简写。`X+`表示匹配一个或多个字母X。

`?` 匹配 1 个或 0 个，是`{0,1}`的简写。`X?`表示匹配0个或1个字母X。  

`{X}`只匹配 X 个字符。`\d{3}`表示匹配3个数字，`.{10}`表示匹配任何长度是 10的字符串。  

`{X,Y}` 匹配 >=X 且 <=Y 个。`\d{1,4}`表示匹配至少1个最多4个数字。  

`*?` 如果?是限定符*或+或?或{}后面的第一个字符，那么表示非贪婪模式（尽可能少的匹配字符），而不是默认的贪婪模式。  

#### &emsp;&emsp;9.4 分组和反向引用

小括号()可以达到对正则表达式进行分组的效果。  
模式分组后会在正则表达式中创建反向引用。反向引用会保存匹配模式分组的字符串片断，这使得我们可以获取并使用这个字符串片断。  
在以正则表达式替换字符串的语法中，是通过`$`来引用分组的反向引用，`$0`是匹配完整模式的字符串（注意在 JavaScript 中是用`$&`表示）；`$1`是第一个分组的反向引用；`$2`是第二个分组的反向引用，以此类推。

示例：

```java
package com.wuxianjiezh.demo.regex;

public class RegexTest {
    public static void main(String[] args) {
        // 去除单词与 , 和 . 之间的空格
        String Str = "Hello , World .";
        String pattern = "(\\w)(\\s+)([.,])";
        // $0 匹配 `(\w)(\s+)([.,])` 结果为 `o空格,` 和 `d空格.`
        // $1 匹配 `(\w)` 结果为 `o` 和 `d`
        // $2 匹配 `(\s+)` 结果为 `空格` 和 `空格`
        // $3 匹配 `([.,])` 结果为 `,` 和 `.`
        System.out.println(Str.replaceAll(pattern, "$1$3")); // Hello, World.
    }
}
```

上面的例子中，我们使用了 [.] 来匹配普通字符 . 而不需要使用 [\\.]。因为正则对于 [] 中的 .，会自动处理为 [\.]，即普通字符 . 进行匹配。

##### &emsp;&emsp;&emsp;9.4.1 仅分组但无反向引用

当我们在小括号 () 内的模式开头加入 ?:，那么表示这个模式仅分组，但不创建反向引用。

示例：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "img.jpg";
        // 分组且创建反向引用
        Pattern pattern = Pattern.compile("(jpg|png)");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
            System.out.println(matcher.group(1));
        }
    }
}
>>>>>
jpg
jpg
```

若源码改为：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "img.jpg";
        // 分组但不创建反向引用
        Pattern pattern = Pattern.compile("(?:jpg|png)");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
            System.out.println(matcher.group(1));
        }
    }
}
>>>>>
jpg
Exception in thread "main" java.lang.IndexOutOfBoundsException: No group 1
    at java.util.regex.Matcher.group(Matcher.java:538)
    at com.wuxianjiezh.regex.RegexTest.main(RegexTest.java:15)
```

##### &emsp;&emsp;&emsp;9.4.2 分组的反向引用副本

Java中可以在小括号中使用`?<name>`将小括号中匹配的内容保存为一个名字为 name的副本。

示例：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "@wxj 你好啊";
        Pattern pattern = Pattern.compile("@(?<first>\\w+\\s)"); // 保存一个副本
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
            System.out.println(matcher.group(1));
            System.out.println(matcher.group("first"));
        }
    }
}
>>>>>
@wxj
wxj
wxj
```

#### &emsp;&emsp;9.5 否定先行断言

称为Negative lookahead。  

我们可以创建否定先行断言模式的匹配，即某个字符串后面不包含另一个字符串的匹配模式。  

否定先行断言模式通过 (?!pattern) 定义。比如，我们匹配后面不是跟着 "b" 的 "a"：a(?!b)

#### &emsp;&emsp;9.6 指定正则表达式的模式

可以在正则的开头指定模式修饰符。  

(?i) 使正则忽略大小写。  

(?s) 表示单行模式（"single line mode"）使正则的 . 匹配所有字符，包括换行符。  

(?m) 表示多行模式（"multi-line mode"），使正则的 ^ 和 $ 匹配字符串中每行的开始和结束。  

#### &emsp;&emsp;9.7 Java中的反斜杠

反斜杠 \ 在 Java 中表示转义字符，这意味着 \ 在 Java 拥有预定义的含义。

这里例举两个特别重要的用法：  

1. 在匹配 . 或 { 或 [ 或 ( 或 ? 或 $ 或 ^ 或 * 这些特殊字符时，需要在前面加上`\\`，比如匹配 . 时，Java 中要写为`\\`.，但对于正则表达式来说就是`\.`。  
2. 在匹配 \ 时，Java 中要写为`\\\\`，但对于正则表达式来说就是`\\`。$\color{orange}{注意：}$Java 中的正则表达式字符串有两层含义，首先 Java 字符串转义出符合正则表达式语法的字符串，然后再由转义后的正则表达式进行模式匹配。

#### &emsp;&emsp;9.8 内置的字符串正则处理方法

在 Java 中有四个内置的运行正则表达式的方法，分别是`matches()`、`split()`、`replaceFirst()`、`replaceAll()`。注意`replace()`方法不支持正则表达式。

方法 描述  
`s.matches("regex")` 当仅且当正则匹配整个字符串时返回`true`  
`s.split("regex")` 按匹配的正则表达式切片字符串  
`s.replaceFirst("regex", "replacement")` 替换首次匹配的字符串片段  
`s.replaceAll("regex", "replacement")` 替换所有匹配的字符  
示例代码：

```java
package com.wuxianjiezh.regex;
public class RegexTest {
    public static void main(String[] args) {
        System.out.println("wxj".matches("wxj"));
        System.out.println("----------");
        String[] array = "w x j".split("\\s");
        for (String item : array) {
            System.out.println(item);
        }
        System.out.println("----------");
        System.out.println("w x j".replaceFirst("\\s", "-"));
        System.out.println("----------");
        System.out.println("w x j".replaceAll("\\s", "-"));
    }
}
>>>>>
true
----------
w
x
j
----------
w-x j
----------
w-x-j
```

#### &emsp;&emsp;9.9 模式和匹配

Java中使用正则表达式需要用到两个类，分别为`java.util.regex.Pattern`和 `java.util.regex.Matcher`。
第一步，通过正则表达式创建模式对象 Pattern。
第二步，通过模式对象 Pattern，根据指定字符串创建匹配对象 Matcher。
第三步，通过匹配对象 Matcher，根据正则表达式操作字符串。
如：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String text = "Hello Regex!";
        Pattern pattern = Pattern.compile("\\w+");
        // Java 中忽略大小写，有两种写法：
        // Pattern pattern = Pattern.compile("\\w+", Pattern.CASE_INSENSITIVE);
        // Pattern pattern = Pattern.compile("(?i)\\w+"); // 推荐写法
        Matcher matcher = pattern.matcher(text);
        // 遍例所有匹配的序列
        while (matcher.find()) {
            System.out.print("Start index: " + matcher.start());
            System.out.print(" End index: " + matcher.end() + " ");
            System.out.println(matcher.group());
        }
        // 创建第两个模式，将空格替换为 tab
        Pattern replace = Pattern.compile("\\s+");
        Matcher matcher2 = replace.matcher(text);
        System.out.println(matcher2.replaceAll("\t"));
    }
}
>>>>>
Start index: 0 End index: 5 Hello
Start index: 6 End index: 11 Regex
Hello    Regex!
```

#### &emsp;&emsp;9.10 中文的匹配

[\u4e00-\u9fa5]+ 代表匹配中文字。

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "閑人到人间";
        Pattern pattern = Pattern.compile("[\\u4e00-\\u9fa5]+");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}
>>>>>
閑人到人间
```

#### &emsp;&emsp;9.11 数字范围的匹配

比如，匹配 1990 到 2017。

注意：这里有个新手易范的错误，就是正则 [1990-2017]，实际这个正则只匹配 0 或 1 或 2 或 7 或 9 中的任一个字符。  
正则表达式匹配数字范围时，首先要确定最大值与最小值，最后写中间值。  

正确的匹配方式：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "1990\n2010\n2017";
        // 这里应用了 (?m) 的多行匹配模式，只为方便我们测试输出
        // "^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$" 为判断 1990-2017 正确的正则表达式
        Pattern pattern = Pattern.compile("(?m)^1990$|^199[1-9]$|^20[0-1][0-6]$|^2017$");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}
>>>>>
1990
2010
2017
```

#### &emsp;&emsp;9.12 img标签的匹配

比如，获取图片文件内容，这里我们考虑了一些不规范的img标签写法：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "<img  src='aaa.jpg' /><img src=bbb.png/><img src=\"ccc.png\"/>" +
                "<img src='ddd.exe'/><img src='eee.jpn'/>";
        // 这里我们考虑了一些不规范的 img 标签写法，比如：空格、引号
        Pattern pattern = Pattern.compile("<img\\s+src=(?:['\"])?(?<src>\\w+.(jpg|png))(?:['\"])?\\s*/>");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group("src"));
        }
    }
}
>>>>>
aaa.jpg
bbb.png
ccc.png
```

#### &emsp;&emsp;9.13 贪婪与非贪婪模式的匹配

比如，获取 div 标签中的文本内容：

```java
package com.wuxianjiezh.regex;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegexTest {
    public static void main(String[] args) {
        String str = "<div>文章标题</div><div>发布时间</div>";
        // 贪婪模式
        Pattern pattern = Pattern.compile("<div>(?<title>.+)</div>");
        Matcher matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group("title"));
        }
        System.out.println("--------------");
        // 非贪婪模式
        pattern = Pattern.compile("<div>(?<title>.+?)</div>");
        matcher = pattern.matcher(str);
        while (matcher.find()) {
            System.out.println(matcher.group("title"));
        }
    }
}
>>>>>
文章标题</div><div>发布时间
```
