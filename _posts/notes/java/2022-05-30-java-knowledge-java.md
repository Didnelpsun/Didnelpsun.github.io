---
layout: post
title:  "Java知识点"
date:   2022-05-30 18:24:54 +0800
categories: notes java knowledge
tags: Java 高级 知识
excerpt: "Java知识点"
---

Java

## HashMap和HashTable区别

&emsp;|HashMap|HashTable
:-------:|:---------:|:----------:
效率|高|低
线程安全|否|是
允许key和value为null|是|否
遍历方式|迭代器|迭代器、索引

+ 允许key和value为null：HashMap的key只能有一个且必须在0位置，value可以有多个，这是由于直接使用key.hashcode()，而没有向HasMap一样先判断key是否为null，所以key为null时，调用key.hashcode()会出错，所以hashtable中key也不能为null。

使用拉链法实现，即数组Entry+链表，用于存储键值对。

HashMap当链表增长长度大于阈值（默认为8）会准备扩容，首先判断如果当前数组Entry的长度小于64，那么会选择先进行数组扩容；如果大于等于64时，将链表转化为红黑树。当数据减少，红黑树高低于6时，红黑树会重新变为链表。

HashTable默认capacity是11，默认负载因子是0.75。当前表中的Entry数量，如果超过了阈值，就会扩容，即调用rehash方法，重新计算每个键值对的hashCode，判断新的容量是否超过了上限，没超过就新建一个新数组，大小为原数组的2倍+1，将旧数的键值对重新hash添加到新数组中。

## HashMap安全性

方法一:通过Collections.synchronizedMap()返回一个新的Map,这个新的map就是线程安全的.这个要求大家习惯基于接口编程,因为返回的并不是HashMap,而是一个Map的实现。

方法二:重新改写了HashMap,具体的可以查看java.util.concurrent.ConcurrentHashMap.这个方法比方法一有了很大的改进。

方法一特点:
通过Collections.synchronizedMap()来封装所有不安全的HashMap的方法,就连toString, hashCode都进行了封装.封装的关键点有2处1)使用了经典的synchronized来进行互斥,2)使用了代理模式new了一个新的类,这个类同样实现了Map接口.在Hashmap上面,synchronized锁住的是对象,所以第一个申请的得到锁,其他线程将进入阻塞,等待唤醒.优点:代码实现十分简单,一看就懂.缺点:从锁的角度来看;方法一直接使用了锁住方法,基本上是锁住了尽可能大的代码块.性能会比较差。

方法二特点:
重新写了HashMap,比较大的改变有如下几点.使用了新的锁机制,把HashMap进行了拆分,拆分成了多个独立的块,这样在高并发的情况下减少了锁冲突的可能,使用的是NonfairSync.这个特性调用CAS指令来确保原子性与互斥性.当如果多个线程恰好操作到同一个segment上面,那么只会有一个线程得到运行.
优点:需要互斥的代码段比较少;性能会比较好.ConcurrentHashMap把整个Map切分成了多个块,发生锁碰撞的几率大大降低，性能会比较好.缺点:代码繁琐

## ArrayList和LinkedList

ArrayList和LinkedList都实现了List接口，他们有以下的不同点：

ArrayList是基于索引的数据接口，它的底层是数组。它可以以o(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。

相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。

LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

1. 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array·获取数据的时间复杂度是O(1),但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。
2. 相对于ArrayList,LinkedList插入是更快的。因为LinkedList 不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList 中插入或删除的时间复杂度仅为o(1)。ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部)。
3. 类似于插入数据，删除数据时， LinkedList也优于ArrayList。
4. LinkedList 需要更多的内存，因为 ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置(一个LinkedList 实例存储了两个值: Node\<E\> first和Node\<E\> last分别表示链表的其实节点和尾节点，每个Node 实例存储了三个值: (E item,Node next,Node pre)。

什么场景下更适宜使用LinkedList，而不用ArrayList。

1. 你的应用不会随机访问数据。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。
2. 你的应用更多的插入和删除元素，更少的读取数据。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。

<!-- ## JDK1.8新技术

提供接口默认default实现。提供面向函数式编程lambda表达式。多重注解。 -->

## 抽象类与接口

相同：

+ 不能实例化。
+ 可以通过子类或实现类进行向上转型作为引用类型。
+ 必须全部实现抽象方法。

不同：

&emsp;|抽象类|接口
构造器|是|否
方法类型|抽象、具体|抽象、默认、静态
成员权限|public|无限制
成员变量类型|变量和常量|常量
继承|一个|多个

抽象类用于全局类型概念，接口用于局部特征行为。

## CAS自旋锁

<https://blog.csdn.net/weixin_46253250/article/details/120910050>。

JVM

## 对象组成结构

+ markword：8字节（64位计算机），包括Lock锁信息，HashCode，GC垃圾处理信息。
+ class pointer：4字节，类型指针，指向当前对象的类型。markword+class pointer即为对象头。
+ instance data：实例数据，即对象中的成员变量。
+ padding：对齐，让对象总大小能被8整除。

## 对象定位方式

+ 直接方式：直接指针。指针->堆中对象实例成员->类型数据指针->方法区的类。
+ 间接方式：句柄方式。指针->实例数据指针；类型数据指针->堆中对象实例成员；方法区的类。

数据库

## ACID

+ 原子性由undalog日志来保狂，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql。
+ 一致性是由其他三大特性保证，程序代码要保证业务上的一致性。
+ 隔离性是由MVCC（多版本并发控制）来保证。
+ 持久性由redolog来保证，mysql修改数据的时候会在redolog中记录一份日志数据，就算数据没有保存成功，只要日志保存成功了，数据仍然不会丢失。

## MVCC

### &emsp;场景

数据库并发场景有三种。分别为：

1. 读读：不存在任何问题。也不需要并发控制。
2. 读写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读、幻读、不可主复读。
3. 写写：有线程安全问题，可能存在更新丢失问题。

MVc是一种用来解决读写冲突的天额并发控制，也就足为事务分配单项增长的时间瑟，为每个修改保存一个版本，版本与牛务时间戳关联，读操作只读该务开始前的数据库的快照，所以MVCC可以为数据库解决一下问题：

1. 在并发读写数据库时，可以做到在读操作时不用阳塞写挨作，写操作也不用阻塞读操作，提高了数据库并发读写的性能。
2. 解决脏读、幻读、不可重复读等事务隔离问题，但是不能解决更新丢失问题。

### &emsp;原理

MVCC的实现原理主要依赖于记录中的三个隐藏字段、undolog、read view来实现的。

#### &emsp;&emsp;隐藏字段

每行记录除了我们自己定义的字段外，还有数据库隐式定义的DB_TRX_JD,DB_ROLL_PTR,DB_ROW_ID等字段。

+ DB_TRX_ID：6字节，最近修改事务id，记录创建这条记录或者最后一次修改该记录的事务id。
+ DB_ROLL_PTR：7字节，回滚指针，指向这条记录的上一个版本，用于配合undolog，指向上一个旧版本。
+ DB_Row_JD：6字节，隐藏的主键，如果数据表没有主键，那么innodb会自动生成一个6字节的row_id。

#### &emsp;&emsp;undo_log

表示在进行insert，delete，update操作的时候产生的方使回滚的日志当。

进行insert操作的时候，产生的undolog只在事务回滚的时候需要，并且在事务提交之后可以被立刻丢弃。

当进行update和delete操作的时候，产生的undolog不仅仅在事务回滚的时候需要，在快照读的时候也需要，所以不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除（当数据发生更新和删除操作的时侯部只是设置一下老记录的deleted_bit，并不是真正的将过时的记录删除，因为为了节省磁盘空间，innodb有专门的purge线程来清除deleted_bit为true的记录，如果某个记录的celeted_id为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定时可以被清除的。

#### &emsp;&emsp;read view

上面的流程如果看明白了，那么要再深入理解下read view的概念。

Read View是事务进行快照读操作的时候生产的读视图，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id，事务的id值是递增的。

其实Read View的最大作用足用来做可见性判断的，也就足说当某个事务在执行快读的时候，对该记录创建一个Read View的识图，把它当作条件去判断当前事务能够看到哪个版本的数据，有可能读取到的是最新的数据，也有可能读取的是当前行记录的undolog中某个版本的数据。

Read View遵循的可见性算法主要是将要被修改的数据的最新记录中的DB_TRX_JD（当前事务id）取出来，与系统当前其他活跃事务的id去对比，如果DB_TRX_IDE跟Read View的展性做了比较，不符合可见性，那么就通过DB_ROLL_PTR回滚指针去取出undolog中的DE_TRX_ID做比较，即邃历链表中的DE_TRX_ID，直到找到满足条件的DB_TRX_ID,这个DB_TRX_ID所在的旧记录就是当前事务能看到的最新老版本数据。

具有三个全局属性：

+ trx_list：一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID。
+ up_limit_id：记录trx_list列表中事务ID最小的ID。
+ low_limit_id：Read View生成时刻系统尚未分配的下一个事务ID。

具体的比较规则如下：

1. 首先比较DB_TRX_ID < up_limit_id,如果小于，则当前事务能看到DB_TRX_ID所在的记录，如果大于等于进入下一个判断。
2. 接下来判断DB_TRX_ID >= low_limit_id,如果大于等于则代表DB_TRX_ID所在的记录在Read View生成后才出现的，那么对于当前事务肯定不可见，如果小于，则进入下一步判断。
3. 判断DB_TRX_ID是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，修改的数据，当前事务也是看不到，如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。

RC、RR级别下的InnoDB快照读有什么不同：因为Read view生成时机的不同，从而造成RC、RR级别下快照读的结果的不同。

1. 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照即Read View；将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read Vview，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见
2. 在RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动和事务的快照，这些事务的修改对于当前事务都是不可见的，而早于Read View创建的事务所做的修改均是可见
3. 在RC级别下，事务中，每次快照读都会新生成一个快照和Read View，这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因。
总结:在RC隔离级别下，是每个快照读都会生成并获取最新的Read View，而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View。

## MySQL隔离级别

MySQL定义了四种隔离级别，包括一些具体规则，用于限定事务内外哪些改变是可见的，哪些改变是不可见的。低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。

### &emsp;读问题

1. 脏读：是指一个事务读取了未提交事务执行过程中的数据。当一个事务的操作正在多次修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据。
2. 不可重复读：不可重复读是指对于数据库中的某个数据，一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了。不可重复读同脏读的区别在于，脏读是一个事务读取了另一未完成的事务执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。
3. 幻读：是事务非独立执行时发生的一种现象，例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有进行修改，而这条数据其实是T2刚刚提交插入的，这就是幻读。幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

### &emsp;READ UNCOMMITTED读取未提交内容

在这个隔离级别，所有事务都可以"看到"未提交事务的执行结果。在这种级别上，可能会产生很多问题，除非用户真的知道自己在做什么，并有很好的理由选择这样做。本隔离级别很少用于实际应用，因为它的性能也不必其他性能好多少，而别的级别还有其他更多的优点。读取未提交数据-也被称为"脏读"。

### &emsp;READ COMMITTED读取提交内容

大多数数据库系统的默认隔离级别(但是不是MySQL的默认隔离级别)，满足了隔离的早先简单定义:一个事务开始时，只能"看见"已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的"不可重复读"。这意味着用户运行同一个语句两次，看到的结果是不同的。

### &emsp;REPEATABLE READ可重复读

MySQL数据库默认的隔离级别。该级别解决了READ UNCOMMITED隔离级别导致的问题。它保证同一事务的多个实例在并发读取事务时，会看到同样的数据行。不过，这会导致另外一个棘手问题"幻读"。InnoDB和Falcon存储引擎通过多版本并发控制MVCC机制解决了幻读问题。

### &emsp;SERIALIZABLE可串行化

该级别是最高级别的隔离级。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时Timeout和锁竞争Lock Contention现象，实际应用中很少使用到这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发的话，也可以选择这种隔离级。

## MySQL聚簇与非聚簇索引

数据和索引是否放在一起，一起就是聚簇，否则就是非聚簇。

mysql的索引类型跟存储引擎是相关的，innodb存储引擎数据文件跟索引文件全部放在ibd文件中，而
myisam的数据文件放在myd文件中，索引放在myi文件中，其实区分聚簇索引和非聚簇索引非常简单，只要判断数据跟索引是否存储在一起就可以了。

innodb存储引擎在进行数据插入的时候，数据必须要跟索引放在一起，如果有主键就使用主键，没有主键就使用唯一键，没有唯一键就使用6字节的rowid，因此跟数据绑定在一起的就是聚簇索引，而为了避免数据冗余存储，其他的索引的叶子节点中存储的都是聚簇索引的key值，因此innodb中既有聚簇索引也有非聚簇索引，而myisam中只有非聚簇索引。


MyBatis

Mybait的优点：

1. 简单易学，容易上手（相比于Hibernate）基于SQL编程。
2. JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接。
3. 很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持，而JDBC提供了可扩展性，所以只要这个数据库有针对Java的jar包就可以就可以与MyBatis兼容），开发人员不需要考虑数据库的差异性。
4. 提供了很多第三方插件，分页插件/逆向工程。
5. 能够与Spring很好的集成。
6. MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML里，从程序代码中彻底分离，解除SQL与程序代码的耦合，便于统一管理和优化，并可重用。
7. 提供XML标签，支持编写动态SQL语句。
8. 提供映射标签，支持对象与数据库的ORM字段关系映射。
9. 提供对象关系映射标签，支持对象关系组建维护。

MyBatis框架的缺点

1. SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。
2. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

+ #\{\}是预编译处理，\$\{\}是字符串替换。
+ Mybatis在处理#\{\}时，会将SQL中的#\{\}替换为?号，调用PreparedStatement的set方法来赋值。
+ Mybatis在处理\$\{\}时，就是把\$\{\}替换成变量的值。
+ 使用#0可以有效的防止SQL注入，提高系统安全性

Spring

## BeanFactory和ApplicationContext

相同:

+ Spring提供了两种不同的IOC容器，一个是BeanFactory，另外一个是ApplicationContext，它们都是Javainterface，ApplicationContext继承于BeanFactory(ApplicationContext继承ListableBeanFactory。
+ 它们都可以用来配置XML属性，也支持属性的自动注入。
+ 而ListableBeanFactory继承BeanFactory，BeanFactory和ApplicationContext 都提供了一种方式，使用getBean("bean name")获取bean。

不同:

+ 当你调用getBean()方法时，BeanFactory仅实例化bean，而ApplicationContext 在启动容器的时候实例化单例bean，不会等待调用getBean()方法时再实例化。
+ BeanFactory不支持国际化，即i18n，但ApplicationContext提供了对它的支持。
+ BeanFactory与ApplicationContext之间的另一个区别是能够将事件发布到注册为监听器的bean。
+ BeanFactory的一个核心实现是XMLBeanFactory而ApplicationContext的一个核心实现是ClassPathXmIApplicationContext，Web容器的环境我们使用WebApplicationContext并且增加了getServletContext方法。
+ 如果使用自动注入并使用BeanFactory，则需要使用API注册AutoWiredBeanPostProcessor，如果使用ApplicationContext，则可以使用XML进行配置。
+ 简而言之，BeanFactory提供基本的IOC和DI功能，而ApplicationContext提供高级功能，BeanFactory可用于测试和非生产使用，但ApplicationContext是功能更丰富的容器实现，应该优于BeanFactory。
