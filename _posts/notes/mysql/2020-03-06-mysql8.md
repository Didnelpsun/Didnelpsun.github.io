---
layout: post
title:  "MySQL基础8"
date:   2020-03-06 23:26:40 +0800
categories: notes mysql base
tags: mysql MySQL 基础
excerpt: "表查询与视图"
---

对于已经谈过的查询方法，这里并不会说到，只会谈到与[SQL教程]({{ site_url }}/notes/sql)不同的地方

## 分页与限制

在[SQL教程的分页和限制]({% post_url notes/sql/2019-07-10-sql4 %})中我们讲到了使用LIMIT来控制显示的数据。但是在MySQL中如果要控制偏移量并不需要使用OFFSET，<span style="color:aqua">格式：</span>`LIMIT [位置偏移量,] 行数`，偏移量是可选的，如果是LIMIT 3,5就是偏移3条记录选取五个，即从2号到6号。

&emsp;

## 排序

### &emsp;FIELD()

可以使用ORDER BY对于属性列进行排序，但是这种排序往往是根据属性值的数字顺序或者字符顺序，如果我们要规定一系列字符串的顺序，可以使用`FIELD()`函数为列中的值定义自己的自定义排序顺序。如：

```sql
--将状态按照break、work、out、attend meeting四个顺序进行排序--
SELECT
    status
FROM
    test
ORDER BY FIELD(
    status,
    `break`,
    `work`,
    `out`,
    `attend meeting`
)
```

### &emsp;自然排序

同时因为说到了一般的排序是按照字符串排序的，且由第一个字符不断向后对比，NULL大于其他值，这就导致了如果是字符串的数字，那么10小于2等现象会出现，那么我们如何对它们进行自然的排序呢？

第一种方式是将同时具有字符串和数字的属性列拆开，分别对它们排序再使用`CONCAT()`合并。

```sql
--在之前首先将数据分为两部分prefix和suffix，然后再合并--
SELECT
    CONCAT(prefix, suffix)
FROM
    items
ORDER BY prefix , suffix;
```

第二种，如果格式标准可以使用函数对于数据转换，然后对转换后的结果进行排序：

```sql
SELECT
    item_no
FROM
    items
ORDER BY CAST(item_no AS UNSIGNED) , item_no;
--将数据转换成整型--
```

第三种也是针对数字字符串的排序，但是前两种都是针对不同长度的数据且数字顺序较乱的情况下，如果字符部分不变，而只是数字部分变化呢？又或者更简单的，如何排序纯数字字符串呢？使用`LENGTH()`：

```sql
--对J-1，J-2...排序--
SELECT 
    item_no
FROM
    items
ORDER BY LENGTH(item_no) , item_no;
--首先对长度排序，越短的越在前面，相同的再比较数字大小--
```

&emsp;

## 常用运算符

算术运算符就是加减乘除模。

比较运算符除了=、<、<=、>=、>、<>或!=还有一些特别的运算符。

<=>是安全等于，如果两边表达式相等或者都为NULL时返回TRUE，如果双方不等或者一方为NULL就返回FALSE，不会返回UNKNOWN。而=当表达式有一个NULL就会返回UNKNOWN。

ISNULL或IS NULL与IS NOT NULL判断是否为空值。

LEAST(参数1,参数2...)返回最小值，GREATEST(参数1,参数2...)返回最大值，这两个参数中有一个NULL，则整个都返回NULL。

参数 BETWEEN 极小值 AND 极大值，如果表达式大于或等于最小值，小于或等于最大值就返回1，否则为0。

IN和NOT IN判断值是否在列表中。

逻辑运算符有四个：

逻辑运算符|说明
:-------:|:--:
NOT或者!|逻辑非
AND或者&&|逻辑与
OR或者\|\||逻辑或
XOR|逻辑异或

位运算符如下：

位运算符|说明
\||按位或
&|按位与
^|按位异或
\<\<|按位左移
\>\>|按位右移
~|按位取反，反转所有比特

&emsp;

## 匹配与正则

选项|说明|例子|匹配值示例
:--:|:--|:---|:--------
^|匹配文本的开始字符|'^b' 匹配以字母b开头的字符串|book、big、banana、 bike
$|匹配文本的结束字符|'st$' 匹配以st结尾的字符串|test、resist、persist
.|匹配任何单个字符|'b.t' 匹配任何b和t之间有一个字符|bit、bat、but、bite
\*|匹配零个或多个在它前面的字符|'f*n' 匹配字符n前面有任意个字符f|fn、fan、faan、abcn
+|匹配前面的字符1次或多次|'ba+' 匹配以b开头，后面至少紧跟一个 a|ba、bay、bare、battle
<字符串>|匹配包含指定字符的文本|'fa'|fan、afa、faad
[字符集合]|匹配字符集合中的任何一个字符|'[xz]'匹配 x 或者 z|dizzy、zebra、x-ray、 extra
[^]|匹配不在括号中的任何字符|'[^abc]' 匹配任何不包含 a、b 或c的字符串|desk、fox、f8ke
字符串{n,}|匹配前面的字符串至少n次|b{2} 匹配 2 个或更多的 b|bbb、 bbbb、 bbbbbbb
字符串{n,m}|匹配前面的字符串至少n次，至多m次|b{2,4} 匹配最少2个， 最多4个 b|bbb、 bbbb

&emsp;

## 连接

MySQL支持INNER JOIN、LEFT JOIN、RIGHT JOIN、CROSS JOIN，但是不支持FULL JOIN，如果要使用，可以使用UNION来连接左右外连接的结果。其他的连接方式基本和SQL标准一致。

然后MySQL还多了一个关键字USING，这个关键字怎么使用呢？

<span style="color:aqua">格式：</span>`SELECT 列名1,列名2... FROM 表1 INNER JOIN 表2 USING(相同的列);`

而我们一般是什么格式呢？`SELECT 列名1,列名2... FROM 表1 INNER JOIN 表2 ON 表1.相同的列=表2.相同的列;`也就是说USING就是替代原来的ON子句，但是这是有限制的，必须是INNER JOIN且两个表属性名相同。

&emsp;

## 子查询

&emsp;

## 视图

视图定义中不能引用 TEMPORARY 表（临时表），不能创建 TEMPORARY 视图。

### &emsp;重命名

<span style="color:aqua">格式：</span>`RENAME TABLE 视图名 TO 新视图名;`

### &emsp;查看

查看视图<span style="color:aqua">格式：</span>`DESCRIBE 视图名;`

DESCRIBE 一般情况下可以简写成 DESC，输入这个命令的执行结果和输入 DESCRIBE 是一样的。

### &emsp;更新

视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。对视图的修改就是对基本表的修改，因此在修改时，要满足基本表的数据定义。

某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系。

还有一些特定的其他结构，这些结构会使得视图不可更新。更具体地讲，如果视图包含以下结构中的任何一种，它就是不可更新的：

+ 聚合函数 SUM()、MIN()、MAX()、COUNT() 等。
+ DISTINCT 关键字。
+ GROUP BY 子句。
+ HAVING 子句。
+ UNION 或 UNION ALL 运算符。
+ 位于选择列表中的子查询。
+ FROM 子句中的不可更新视图或包含多个表。
+ WHERE 子句中的子查询，引用 FROM 子句中的表。
+ ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。
