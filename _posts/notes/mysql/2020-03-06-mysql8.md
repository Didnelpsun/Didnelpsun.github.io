---
layout: post
title:  "MySQL基础8"
date:   2020-03-06 23:26:40 +0800
categories: notes mysql base
tags: mysql MySQL 基础 分页 排序 运算符 匹配 正则 连接 子查询 派生表 临时表 视图
excerpt: "数据操作与视图"
---

对于已经谈过的查询方法，这里并不会说到，只会谈到与[SQL教程]({{ site_url }}/notes/sql)不同的地方

## 分页与限制

在[SQL教程的分页和限制]({% post_url notes/sql/2019-07-10-sql4 %})中我们讲到了使用LIMIT来控制显示的数据。但是在MySQL中如果要控制偏移量并不需要使用OFFSET，<span style="color:aqua">格式：</span>`LIMIT [位置偏移量,] 行数`，偏移量是可选的，如果是LIMIT 3,5就是偏移3条记录选取五个，即从2号到6号。

&emsp;

## 排序

### &emsp;FIELD()

可以使用ORDER BY对于属性列进行排序，但是这种排序往往是根据属性值的数字顺序或者字符顺序，如果我们要规定一系列字符串的顺序，可以使用`FIELD()`函数为列中的值定义自己的自定义排序顺序。如：

```sql
--将状态按照break、work、out、attend meeting四个顺序进行排序--
SELECT
    status
FROM
    test
ORDER BY FIELD(
    status,
    `break`,
    `work`,
    `out`,
    `attend meeting`
)
```

### &emsp;自然排序

同时因为说到了一般的排序是按照字符串排序的，且由第一个字符不断向后对比，NULL大于其他值，这就导致了如果是字符串的数字，那么10小于2等现象会出现，那么我们如何对它们进行自然的排序呢？

第一种方式是将同时具有字符串和数字的属性列拆开，分别对它们排序再使用`CONCAT()`合并。

```sql
--在之前首先将数据分为两部分prefix和suffix，然后再合并--
SELECT
    CONCAT(prefix, suffix)
FROM
    items
ORDER BY prefix , suffix;
```

第二种，如果格式标准可以使用函数对于数据转换，然后对转换后的结果进行排序：

```sql
SELECT
    item_no
FROM
    items
ORDER BY CAST(item_no AS UNSIGNED) , item_no;
--将数据转换成整型--
```

第三种也是针对数字字符串的排序，但是前两种都是针对不同长度的数据且数字顺序较乱的情况下，如果字符部分不变，而只是数字部分变化呢？又或者更简单的，如何排序纯数字字符串呢？使用`LENGTH()`：

```sql
--对J-1，J-2...排序--
SELECT 
    item_no
FROM
    items
ORDER BY LENGTH(item_no) , item_no;
--首先对长度排序，越短的越在前面，相同的再比较数字大小--
```

&emsp;

## 常用运算符

算术运算符就是加减乘除模。

比较运算符除了=、<、<=、>=、>、<>或!=还有一些特别的运算符。

<=>是安全等于，如果两边表达式相等或者都为NULL时返回TRUE，如果双方不等或者一方为NULL就返回FALSE，不会返回UNKNOWN。而=当表达式有一个NULL就会返回UNKNOWN。

ISNULL或IS NULL与IS NOT NULL判断是否为空值。

LEAST(参数1,参数2...)返回最小值，GREATEST(参数1,参数2...)返回最大值，这两个参数中有一个NULL，则整个都返回NULL。

参数 BETWEEN 极小值 AND 极大值，如果表达式大于或等于最小值，小于或等于最大值就返回1，否则为0。

IN和NOT IN判断值是否在列表中。

逻辑运算符有四个：

逻辑运算符|说明
:-------:|:--:
NOT或者!|逻辑非
AND或者&&|逻辑与
OR或者\|\||逻辑或
XOR|逻辑异或

位运算符如下：

位运算符|说明
\||按位或
&|按位与
^|按位异或
\<\<|按位左移
\>\>|按位右移
~|按位取反，反转所有比特

&emsp;

## 匹配与正则

选项|说明|例子|匹配值示例
:--:|:--|:---|:--------
^|匹配文本的开始字符|'^b' 匹配以字母b开头的字符串|book、big、banana、 bike
$|匹配文本的结束字符|'st$' 匹配以st结尾的字符串|test、resist、persist
.|匹配任何单个字符|'b.t' 匹配任何b和t之间有一个字符|bit、bat、but、bite
\*|匹配零个或多个在它前面的字符|'f*n' 匹配字符n前面有任意个字符f|fn、fan、faan、abcn
+|匹配前面的字符1次或多次|'ba+' 匹配以b开头，后面至少紧跟一个 a|ba、bay、bare、battle
<字符串>|匹配包含指定字符的文本|'fa'|fan、afa、faad
[字符集合]|匹配字符集合中的任何一个字符|'[xz]'匹配 x 或者 z|dizzy、zebra、x-ray、 extra
[^]|匹配不在括号中的任何字符|'[^abc]' 匹配任何不包含 a、b 或c的字符串|desk、fox、f8ke
字符串{n,}|匹配前面的字符串至少n次|b{2} 匹配 2 个或更多的 b|bbb、 bbbb、 bbbbbbb
字符串{n,m}|匹配前面的字符串至少n次，至多m次|b{2,4} 匹配最少2个， 最多4个 b|bbb、 bbbb

&emsp;

## 连接

MySQL支持INNER JOIN、LEFT JOIN、RIGHT JOIN、CROSS JOIN，但是不支持FULL JOIN，如果要使用，可以使用UNION来连接左右外连接的结果。其他的连接方式基本和SQL标准一致。

然后MySQL还多了一个关键字USING，这个关键字怎么使用呢？

<span style="color:aqua">格式：</span>`SELECT 列名1,列名2... FROM 表1 INNER JOIN 表2 USING(相同的列);`

而我们一般是什么格式呢？`SELECT 列名1,列名2... FROM 表1 INNER JOIN 表2 ON 表1.相同的列=表2.相同的列;`也就是说USING就是替代原来的ON子句，但是这是有限制的，必须是INNER JOIN且两个表属性名相同。

&emsp;

## 子查询与派生表

子查询指一个查询语句嵌套在另一个查询语句内部的查询，在 SELECT 子句中先计算子查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。

子查询中常用的操作符有 ANY（SOME）、ALL、IN 和 EXISTS。

子查询可以添加到 SELECT、UPDATE 和 DELETE 语句中，而且可以进行多层嵌套。子查询也可以使用比较运算符，如"<"、"<="、">"、">="、"！="等。

```sql
SELECT name FROM tb_students_info
WHERE dept_id IN
    (SELECT dept_id
    FROM tb_departments
    WHERE dept_type= 'A' );
```

我们可能已经关注到了这个查询条件中的查询语句，显然这里面的查询就又新产生了一个表。往往这样的就叫派生表，但是也不是所有这种被嵌套的表都是派生表，当SELECT语句的FROM子句中使用<span style="color:orange">独立子查询</span>时，我们将其称为派生表。派生表和子查询通常可互换使用。而如果不是独立子查询，就说明被嵌套的表和外面的表是一体的，也就不存在派生这个说法了。

```sql
SELECT 列名
FROM(
    SELECT 列名 --被包裹的就是派生表
    FROM 表名 --
)派生表别名
WHERE 派生表别名.属性 条件;
```

派生表必须含有别名，不然会报错：Every derived table must have its own alias.

```sql
SELECT 
    productName, sales
FROM
    (SELECT 
        productCode, 
        ROUND(SUM(quantityOrdered * priceEach)) sales
    FROM
        orderdetails
    INNER JOIN orders USING (orderNumber)
    WHERE
        YEAR(shippedDate) = 2013
    GROUP BY productCode
    ORDER BY sales DESC
    LIMIT 5) top5products2013
INNER JOIN
    products USING (productCode);
```

&emsp;

## 临时表

在MySQL中，临时表是一种特殊类型的表，它允许你存储一个临时结果集，可以在单个会话中多次重用。派生表类似于临时表，但是在SELECT语句中使用派生表比临时表简单得多，因为它不需要创建临时表的步骤。

当使用JOIN子句查询需要单个SELECT语句的数据是复杂的时候，临时表非常方便。 在这种情况下，我们就可以使用临时表来存储直接结果，并使用另一个查询来处理它。

MySQL临时表具有以下特殊功能：

+ 使用CREATE TEMPORARY TABLE语句创建临时表。请注意，在CREATE和TABLE关键字之间添加TEMPORARY关键字。
+ 当会话结束或连接终止时，MySQL会自动删除临时表。当您不再使用临时表时，也可以使用DROP TABLE语句来显式删除临时表。
+ 一个临时表只能由创建它的客户机访问。不同的客户端可以创建具有相同名称的临时表，而不会导致错误，因为只有创建临时表的客户端才能看到它。 但是，在同一个会话中，两个临时表不能共享相同的名称。
+ 临时表可以与数据库中的普通表具有相同的名称，不过原表就将无法使用。 例如，如果在一个数据库中创建一个名为employees的临时表，则现有的employees表将变得无法访问。 对employees表发出的每个查询现在都是指employees临时表。 当删除您临时表时，永久employees表可以再次访问。

<span style="color:red">警告：</span>即使临时表可以与永久表具有相同的名称，但不推荐。 因为这可能会导致混乱或意外的数据丢失。例如，如果与数据库服务器的连接丢失，并且你自动重新连接到服务器，则不能区分临时表和永久性表。 然后，你又发出一个DROP TABLE语句，这个时候删除的可能是永久表而不是临时表，这种结果是不可预料的。

### &emsp;创建

和普通的创建表并没什么区别，只需要将TEMPORARY关键字添加到CREATE TABLE语句的中间。

```sql
例如，以下语句创建一个临时表，按照收入存储前5名客户：
CREATE TEMPORARY TABLE top5customers
SELECT p.customerNumber,
       c.customerName,
       FORMAT(SUM(p.amount),2) total
FROM payments p
INNER JOIN customers c ON c.customerNumber = p.customerNumber
GROUP BY p.customerNumber
ORDER BY total DESC
LIMIT 5;
```

然后从top5customers临时表中查询数据，例如：`SELECT * FROM top5customers;`

### &emsp;删除

可以使用DROP TABLE语句来删除临时表，但最好添加TEMPORARY关键字如下：`DROP TEMPORARY TABLE 临时表名;`

DROP TEMPORARY TABLE语句仅删除临时表，而不是永久表。 当将临时表命名为永久表的名称相同时，它可以避免删除永久表的错误。

如果尝试使用DROP TEMPORARY TABLE语句删除永久表，则会收到一条错误消息，指出您尝试删除的表是未知的。

如果开发使用连接池或持久连接的应用程序，则不能保证临时表在应用程序终止时自动删除。因为应用程序使用的数据库连接可能仍然打开并放置在其他客户端使用的连接池中。 因此，当不再使用它们时马上删除临时表，这是一个很好的做法。

&emsp;

## 视图

视图定义中不能引用 TEMPORARY 表（临时表），不能创建 TEMPORARY 视图。

### &emsp;重命名

<span style="color:aqua">格式：</span>`RENAME TABLE 视图名 TO 新视图名;`

### &emsp;查看

查看视图<span style="color:aqua">格式：</span>`DESCRIBE 视图名;`

DESCRIBE 一般情况下可以简写成 DESC，输入这个命令的执行结果和输入 DESCRIBE 是一样的。

### &emsp;更新

视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。对视图的修改就是对基本表的修改，因此在修改时，要满足基本表的数据定义。

某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系。

还有一些特定的其他结构，这些结构会使得视图不可更新。更具体地讲，如果视图包含以下结构中的任何一种，它就是不可更新的：

+ 聚合函数 SUM()、MIN()、MAX()、COUNT() 等。
+ DISTINCT 关键字。
+ GROUP BY 子句。
+ HAVING 子句。
+ UNION 或 UNION ALL 运算符。
+ 位于选择列表中的子查询。
+ FROM 子句中的不可更新视图或包含多个表。
+ WHERE 子句中的子查询，引用 FROM 子句中的表。
+ ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。
