---
layout: post
title:  "Spring基础6"
date:   2020-03-24 10:57:02 +0800
categories: notes spring base
tags: spring 基础
excerpt: "自动装配"
---

依赖注入和自动装配息息相关。依赖注入的本质就是装配，装配是依赖注入的具体行为。

依赖注入有两种形式：构造器注入和setter注入。也就是我们在xml中写的一堆\<bean></bean>，我们每一个依赖bean就要写一个实例，如果bean太多我们还这样写就会非常麻烦，更何况我们还有把有关联的bean装配起来，一旦bean很多，就不好维护了。

为此Spring使用自动装配解决这个问题，开发人员不用关心具体装配哪个bean的引用，识别工作由Spring来完成，因此一般配有自动监测来和自动装配配合完成。自动装配其实就是将依赖注入"自动化"的一个简化配置的操作。也就是说我们只用实例化我们在应用程序中要使用的实例，而它依赖的实例将由Spring来实例化，如之前一直在使用的HelloWorld类。

自动配置有两大类方式，跟之前的依赖注入和实例化一样，一种是xml，一种是注解。

xml的\<bean>配置中通添加autowire属性实现四种形式的自动装配，byName, byType, constructor, autodetect。byName就是会将与属性的名字一样的bean进行装配。byType就同属性一样类型的bean进行装配。constructor就是通过构造器来将类型与参数相同的bean进行装配。autodetect是constructor与byType的组合，会先进行constructor，如果不成功，再进行byType。

Spring2.5之后提供了注解方式的自动装配。但是要使用这些注解，需要在配置文件中配置<context:annotation-config />。只有加上这一配置，才可以使用注解进行自动装配，默认情况下基于注解的装配是被禁用的。常用的自动装配注解有以下几种：@Autowired，@Resource，@Inject，@Qualifier，@Named。

<span style="color:orange">注意：</span>@Autowired注解是byType类型的，因此会将接口的实现类取代接口，自动装配给控制类。

## @Autowired

表示自动装配。这是什么意思？也就是说一个类的创建依赖与另一个类的创建，比如一个类的构造方法中包含着另一个类，或者一个类的属性包含着另一个类。对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。在使用@Autowired之前，我们对一个bean配置起属性时，是用的`<property name="属性名" value=" 属性值"/>`

如果我们两个实例间有调用的关系，如再抽象化HelloWorld类，并重新定义一个User类：

```java
package org.didnelpsun.test;
import org.springframework.stereotype.Component;
import javax.swing.*;
@Component
public class HelloWorld {
    private String words;
    //重写构造方法
    public HelloWorld(){
        System.out.println("HelloWorldClass...");
    }
    public void SetWords(String sayword){
        this.words = sayword;
    }
    //动作方法
    public void SayHello(){
        System.out.println(this.words);
    }
}
```

这一段代码有什么不同？首先我们将所有的与人相关的动作都抽离出去，HelloWorld类只包含着一个私有变量，一个设置要显示的字符串的方法，从外面获取对应的参数，和一个打印字符串的方法。记得要加@Component，不然会报错：Exception in thread "main" org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.didnelpsun.test.User' available。

```java
//User.java
package org.didnelpsun.test;
import org.springframework.beans.factory.annotation.Autowired;
@Component
public class User {
    private static final String username = "Didnelpsun";
    private HelloWorld helloWorld;
    @Autowired
    public void setHelloWorld(HelloWorld helloWorld){
        this.helloWorld = helloWorld;
    }
    public void Say(){
        System.out.println(this.username);
        this.helloWorld.SayHello();
    }
}
```

首先这个User类中设置一个私有常量代表用户名，并且有一个私有变量，使用一个setter方法来设置属性。最后使用Say方法来打印。@Autowired应该写在建立依赖的方法上面。然后我们再思考一下什么叫依赖。HelloWorld类的私有属性的设置是传入一个字符串，而User类的私有属性的设置是传入另一个类，那么后面这一对关系就是属于依赖。

然后我们修改App.java：

```java
//将hello.setWords("nmsl");
//hello.saySomeThing();删除
//导入User类
import org.didnelpsun.test.User;

User Didenelpsun = welcomeContext.getBean(User.class);
hello.SetWords("welcome!");
Didenelpsun.setHelloWorld(hello);
Didenelpsun.Say();
```

![测试输出][testoutput]

那么如何体现自动装配呢？我们可以将App.java的Didenelpsun.setHelloWorld(hello);注释掉，这是不显示将hello实例注入到Didnelpsun的类中，而由Spring的注释注入，我们输出会发现是一样的结果。

我们之前自动注入是写在set函数中，也就是set方法是自动注入对象的，但是实际上我们连这一步都可以不需要。直接在属性上标准，表名这个属性是被自动注入的，而就可以省略后面的setter方法了。然后将App.java中的对应的setter方法也注释掉：

```java
//User.java
package org.didnelpsun.test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
@Component
public class User {
    private static final String username = "Didnelpsun";
    @Autowired
    private HelloWorld helloWorld;
//    public void setHelloWorld(HelloWorld helloWorld){
//        this.helloWorld = helloWorld;
//    }
    public void Say(){
        System.out.println(this.username);
        this.helloWorld.SayHello();
    }
}
```

```java
//App.java
package org.didnelpsun;
//项目入口
import org.didnelpsun.test.HelloWorld;
import org.didnelpsun.test.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.stereotype.Component;
@ComponentScan
public class App
{
    //获取私有属性，这个属性是应用文档属性
    private static ApplicationContext welcomeContext;
    public static void main(String args[]){
        welcomeContext = new AnnotationConfigApplicationContext(App.class);
        HelloWorld hello = welcomeContext.getBean(HelloWorld.class);
        User Didenelpsun = welcomeContext.getBean(User.class);
        hello.SetWords("welcome!");
//        Didenelpsun.setHelloWorld(hello);
        Didenelpsun.Say();
    }
}
```

输出是一样的。也就是说使用了这个标准后默认的this的setter和getter方法都不用写了。getter方法就是返回对象。

&emsp;

## xml中配置ref

如果我们想要不用显式的构造依赖的类而使用实例，除了添加注释，还可以使用之前提到过的property的ref属性。但是这时候我们就必须显式的写出setter和getter方法了。但是我们在使用实例时不用传入参数或者传入依赖类了，因为我们在xml文件中已经配置好，可以直接拿出实例进行使用，而不用构造出依赖的类。不过从此看来其实注释能更节省代码。全部的代码如下：

```java
//App.java
package org.didnelpsun;
//项目入口
import org.didnelpsun.test.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class App
{

    //获取私有属性，这个属性是应用文档属性
    private static ApplicationContext welcomeContext;
    public static void main(String args[]){
        //将Spring beans配置文件引入，使里面的配置可以被使用
        welcomeContext = new ClassPathXmlApplicationContext("SpringBeans.xml");
        //HelloWorld hello = (HelloWorld) welcomeContext.getBean("HelloWorldBean");
        User Didnelpsun = (User) welcomeContext.getBean("DidnelpsunBean");
        Didnelpsun.Say();
    }
}
```

```java
//HelloWorld.java
package org.didnelpsun.test;
public class HelloWorld {
    private String words;
    //重写构造方法
    public HelloWorld(){
        System.out.println("HelloWorldClass...");
    }
    public void setWords(String words) {
        this.words = words;
    }
    //动作方法
    public void SayHello(){
        System.out.println(this.words);
    }
}
```

```java
//User.java
package org.didnelpsun.test;
public class User {
    private static final String username = "Didnelpsun";
    private HelloWorld helloWorld;
    public void setHelloWorld(HelloWorld helloWorld){
        this.helloWorld = helloWorld;
    }
    public void Say(){
        System.out.println(this.username);
        this.helloWorld.SayHello();
    }
}
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id = "HelloWorldBean" class="org.didnelpsun.test.HelloWorld">
        <property name="words" value="hello!"/>
    </bean>
    <bean id = "DidnelpsunBean" class="org.didnelpsun.test.User">
        <property name="helloWorld" ref="HelloWorldBean"/>
    </bean>
</beans>
```

[Spring的ref示例：spring/springxmlref](https://github.com/Didnelpsun/notes/tree/master/spring/springxmlref)

[testoutput]:data:image/png;base64,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

[]
