---
layout: post
title:  "Spring基础7"
date:   2020-03-27 10:57:02 +0800
categories: notes spring base
tags: spring 基础 
excerpt: "自动装配"
---

依赖注入和自动装配息息相关。依赖注入的本质就是装配，装配是依赖注入的具体行为。

依赖注入有两种形式：构造器注入和setter注入。也就是我们在xml中写的一堆\<bean></bean>，我们每一个依赖bean就要写一个实例，如果bean太多我们还这样写就会非常麻烦，更何况我们还有把有关联的bean装配起来，一旦bean很多，就不好维护了。

为此Spring使用自动装配解决这个问题，开发人员不用关心具体装配哪个bean的引用，识别工作由Spring来完成，因此一般配有自动监测来和自动装配配合完成。自动装配其实就是将依赖注入"自动化"的一个简化配置的操作。也就是说我们只用实例化我们在应用程序中要使用的实例，而它依赖的实例将由Spring来实例化，如之前一直在使用的HelloWorld类。

自动配置有两大类方式，跟之前的依赖注入和实例化一样，一种是xml，一种是注解。

xml的\<bean>配置中通添加autowire属性实现四种形式的自动装配，byName, byType, constructor, autodetect。byName就是会将与属性的名字一样的bean进行装配。byType就同属性一样类型的bean进行装配。constructor就是通过构造器来将类型与参数相同的bean进行装配。autodetect是constructor与byType的组合，会先进行constructor，如果不成功，再进行byType。

Spring2.5之后提供了注解方式的自动装配。但是要使用这些注解，需要在配置文件中配置<context:annotation-config />。只有加上这一配置，才可以使用注解进行自动装配，默认情况下基于注解的装配是被禁用的。常用的自动装配注解有以下几种：@Autowired，@Resource，@Inject，@Qualifier，@Named。

<span style="color:orange">注意：</span>@Autowired注解是byType类型的，因此会将接口的实现类取代接口，自动装配给控制类。

不过自动装配也有比较大的问题：

当自动装配始终在同一个项目中使用时，它的效果最好。如果通常不使用自动装配，它可能会使开发人员混淆的使用它来连接只有一个或两个bean定义。不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。

限制|描述
:--:|:--
重写的可能性|你可以使用总是重写自动装配的\<constructor-arg>和\<property>设置来指定依赖关系。
原始数据类型|你不能自动装配所谓的简单类型包括基本类型，字符串和类。
混乱的本质|自动装配不如显式装配精确，所以如果可能的话尽可能使用显式装配。

[Spring项目模板文件：spring/spring](https://github.com/Didnelpsun/notes/tree/master/spring/spring)来搭建。

我们要创建一个实例依赖的案例，然后将参数和属性更改：

```java
//HelloWorld.java
package org.didnelpsun.test;

public class HelloWorld {
    private String words;
    //重写构造方法
    public HelloWorld(){
        System.out.println("HelloWorldClass...");
    }
    public void setWords(String sayword){
        this.words = sayword;
    }
    //动作方法
    public void SayHello(){
        System.out.println(this.words);
    }
}
```

我们的HelloWorld是简单的类，含有一个私有变量，当构造这个实例会打印字符串。然后使用设置函数初始化实例，这个setter函数会接受一个参数，然后下面的SayHello方法会打印这个方法。

```java
//User.java
package org.didnelpsun.test;

public class User {
    private static final String username = "Didnelpsun";
    private HelloWorld helloworldAttri;
    public void setHelloWorld(HelloWorld helloworldPara){
        this.helloworldAttri = helloworldPara;
    }
    public void Say(){
        System.out.println(this.username);
        this.helloworldAttri.SayHello();
    }
}
```

然后在User类中定义一个私有常量和一个HelloWorld类型的属性，这里的setter函数也要传入一个HelloWorld类型的参数，<span style="color:orange">User依赖HelloWorld</span>。然后有一个Say方法，打印属性并调用HelloWorld实例的方法。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id = "HelloWorldBean" class="org.didnelpsun.test.HelloWorld">
    </bean>
    <bean id="UserBean" class="org.didnelpsun.test.User">
        <property name="helloWorld" ref="HelloWorldBean"></property>
    </bean>
</beans>
```

定义两个bean一个是HelloWorld一个是User，如果我们要实现依赖，那么我们要使用ref属性来配置。

```java
//App.java
package org.didnelpsun;
//项目入口
import org.didnelpsun.test.HelloWorld;
import org.didnelpsun.test.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    //获取私有属性，这个属性是应用文档属性
    private static ApplicationContext welcomeContext;
    public static void main(String args[]){
        welcomeContext = new ClassPathXmlApplicationContext("SpringBeans.xml");
        HelloWorld hello = (HelloWorld) welcomeContext.getBean("HelloWorldBean");
        hello.SetWords("welcome!");
        //或者在xml中配置<property name="words" value="hello"/>
        User Didenelpsun = (User) welcomeContext.getBean("UserBean");
        Didenelpsun.Say();
    }
}
```

我们也可以不在App.java中实例化这个HelloWorld类。这些是不影响对应的依赖的。如果我们不在xml中配置依赖，也就是删除`<property name="helloWorld" ref="HelloWorldBean"></property>`，然后再加上`Didenelpsun.setHelloWorld("hello");`也可以配置成功依赖。但是你要注意这是因为在应用程序中配置的，所以这种实例的依赖不是由Spring容器控制的，而是由应用程序控制的，所以你需要关注这些依赖的创建和销毁，当然这是不被建议使用的。

## autowire属性

名称|说明
:--:|:--
no|这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。
byName|由属性名自动装配。Spring容器看到在XML配置文件中bean的自动装配的属性设置为byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的beans的属性进行连接。
byType|由属性数据类型自动装配。Spring容器看到在XML配置文件中bean的自动装配的属性设置为byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的bean，则一个致命的异常将会被抛出。
constructor|类似于byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的bean，则一个致命错误将会发生。
autodetect|Spring首先尝试通过constructor使用自动装配来连接，如果它不执行，Spring尝试通过byType来自动装配。

可以使用byType或者constructor自动装配模式来连接数组和其他类型的集合。

但是实际上这种xml配置并不会经常使用！因为配起来和一般的方法一样，且有一定的限制！

### &emsp;1. byName

按定义来说这种模式由属性名称指定自动装配。Spring容器看作beans，在XML配置文件中beans的auto-wire属性设置为byName。然后，它尝试将它的<span style="color:red">属性类名，即id或name</span>与配置文件中定义为相同名称的beans进行匹配和连接。如果找到匹配项，它将注入这些beans，否则，它将抛出异常。

针对上面的例子，我们应该如何改动呢？注意这个属性值为byName是依赖名字来查找对应的实例的。xml中将参数的ref那行删除，然后改成：`<bean id="User" class="org.didnelpsun.test.User" autowire="byName">`，并且一定要注意改变<span style="color:orange">实例名字</span>！`<bean id = "helloWorld" class="org.didnelpsun.test.HelloWorld">`，因为我们依赖的类为HelloWorld，所以它会找实例名为helloWorld的实例，即将依赖类名的首字母小写，与property属性的ref属性值一样。并且应该在App.java中更改实例的名字来获取实例，并可以来更改被依赖的实例的相关参数。这是一个规范。所以说上面说的按id或者name来匹配是实际上不成立的！它只会按照依赖类名驼峰式名字来匹配！

```xml
<bean id = "helloWorld" class="org.didnelpsun.test.HelloWorld">
    <property name="words" value="hello"/>
</bean>
<bean id="UserBean" class="org.didnelpsun.test.User" autowire="byName">
<!--        <property name="helloWorld" ref="helloWorld"/>-->
</bean>
<!-- <bean id = "helloworldAttri" class="org.didnelpsun.test.HelloWorld">
    <property name="words" value="one"/>
</bean> -->
```

虽然下面的实例的bean是依赖的属性名，但是它是不会匹配到这个属性的，而只会匹配最上面的。重新证明了这个按照name或者id来匹配是不对的。实际上也是按照依赖的class来匹配。

### &emsp;2. byType

定义说这种模式由属性类型指定自动装配。Spring容器看作beans，在XML配置文件中beans的autowire属性设置为byType。然后，如果它的<span style="color:red">类名，即class</span>恰好与配置文件中beans类型名称中的一个相匹配，它将尝试匹配和连接它的属性。如果找到匹配项，它将注入这些beans，否则，它将抛出异常。

如果你将上面的byName属性变为byType属性，那么也可以运行。原因上面已经说了。但是你要注意了，如果你也加入了helloworldAttri这个实例，那么它会报错，因为byType只能拥有一个类的实例，如果有多个同一个类的实例，那么它就不知道找哪个实例了，无论实例名是什么它都会报错。

### &emsp;3. constructor

这种模式与byType非常相似，但它应用于构造器参数。Spring容器看作beans，在XML配置文件中beans的autowire属性设置为constructor。然后，它尝试把它的构造函数的参数与配置文件中beans名称中的一个进行匹配和连线。如果找到匹配项，它会注入这些bean，否则，它会抛出异常。即根据构造方法的参数的数据类型，进行byType模式的自动装配。

```xml
<bean id = "HelloWorldBean" class="org.didnelpsun.test.HelloWorld">
    <property name="words" value="two"/>
</bean>
<bean id="UserBean" class="org.didnelpsun.test.User" autowire="constructor">
<!--<property name="helloWorld" ref="helloWorld"/>-->
</bean>
```

这种情况下实例叫什么都无所谓，因为它是按照class来识别。

```java
public User(HelloWorld helloworldPara){
    helloworldAttri = helloworldPara;
}
```

同时你要注意，如果你在类中加入了构造函数，那么无论你使用什么方式来实例化这个类，你都需要先用构造函数来构造这个实例，都需要先满足构造函数所需要的参数，否则会报错：警告: Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'UserBean' defined in class path resource \[SpringBeans.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate \[org.didnelpsun.test.User]: No default constructor found; nested exception is java.lang.NoSuchMethodException: org.didnelpsun.test.User.\<init>()

### &emsp;4. default

由上级标签\<beans>的default-autowire属性确定。在配置bean时，\<bean>标签中Autowire属性的优先级比其上级标签高，即是说，如果在上级标签中定义default-autowire属性为byName，而在\<bean>中定义为byType时，Spring IoC容器会优先使用\<bean>标签的配置。

&emsp;

所以你会发现这种xml的自动装配并没有我们想象的好用。不谈对于一些实例命名的约束下甚至不如按原来的ref属性，而且基本上不会简便代码。实际上我们在实际运用中也不会用这个属性，而更多是采用的注释的方式，因为这种方式更简便。

注解连线在默认情况下在Spring容器中不打开。因此，在可以使用基于注解的连线之前，我们将需要在我们的Spring配置文件中启用它：`<context:annotation-config/>`

## 自动扫描标签

在此之前，如果我们要使用这些注释应该还要配置好，要使用自动扫描标签来扫描对应的注释，因为它是默认关闭的，如果不开启则注释是不会有作用的。

### &emsp;\<context:annotation-config/>

一般采用的是这个标签，但是如果你加入这个标签后它会报错，说The prefix "context" for element "context:annotation-config" is not bound。

这是因为xml配置文件头部缺少`xmlns:context="http://www.springframework.org/schema/context"`。但是它还是会报错说虽然你配置的很完善但是不知道指向是什么。完整的代码如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context-4.2.xsd">
    <context:annotation-config/>
</beans>
```

我们现在也可以不管它，也可以详细了解一下[注解原理]({% post_url notes/spring/2020-03-28-annotation %})。

我们使用的时候只用在里面加内容就可以了。如果某个类的头上带有特定的注解@Component、@Repository、@Service或@Controller，就会将这个对象作为Bean注入进spring容器。

### &emsp;\<context:component-scan/>

<span style="color:aqua">格式：</span>`<context:component-scan base-package="扫描的包名"/>`。如我的就是\<context:component-scan base-package="org.didnelpsun" />。

我们推荐使用的是这个标签，因为这个标签功能更多。它提供两个子标签：context:include-filter和context:exclude-filter。各代表引入和排除的过滤。

而\<context:annotation-config/>仅能够在已经在已经注册过的bean上面起作用。对于没有在spring容器中注册的bean，它并不能执行任何操作。但是\<context:component-scan/>自动将带有@component,@service,@Repository等注解的对象注册到spring容器中的功能。  

因为/<context:annotation-config/>和/<context:component-scan>同时存在的时候，前者会被忽略。如@autowire，@resource等注入注解只会被注入一次！

## @Autowired

通过@Autowired的使用可以应用到bean属性的setter方法，非setter方法，构造函数和属性。在使用@Autowired之前，我们对一个bean配置起属性时，是用的`<property name="属性名" value=" 属性值"/>`。当Spring发现@Autowired注解时，将自动在代码上下文中找到与其匹配（默认是类型匹配）的Bean，并自动注入到相应的地方去。

@Autowired注释对在哪里和如何完成自动连接提供了更多的细微的控制。可以在setter方法中被用于自动连接bean，就像@Autowired注释，容器，一个属性或者任意命名的可能带有多个参数的方法。它会默认使用byType类型的识别。

那么我们应该如何使用呢？首先还是将所有文件都恢复到最开始的样子。我们使用`<property name="helloWorld" ref="HelloWorldBean"></property>`来配置依赖，我们当然会想把这个配置给删除，甚至想在xml文件中都不实例化依赖的而不被直接使用的HelloWorld类。

### &emsp;与xml混合模式

首先我们根据上面说的xml文件配置中，加入下面的内容：

```xml
<context:component-scan base-package="org.didnelpsun" />
<bean id = "HelloWorldBean" class="org.didnelpsun.test.HelloWorld"/>
<bean id="UserBean" class="org.didnelpsun.test.User"/>
```

请注意这里再也没有说明HelloWorld类和User类两个实例的依赖关系了。因为我们目标输出的实例没有HelloWorld实例，所以也不用获取了。如果你想设置这个实例的words属性值，那么可以在xml中配置：`<property name="words" value="hello"/>`。

```java
//User.java
package org.didnelpsun.test;

import org.springframework.beans.factory.annotation.Autowired;

public class User {
    private static final String username = "Didnelpsun";
    private HelloWorld helloworldAttri;
    @Autowired
    public void setHelloWorld(HelloWorld helloworldPara){
        this.helloworldAttri = helloworldPara;
    }
    public void Say(){
        System.out.println(this.username);
        this.helloworldAttri.SayHello();
    }
}
```

因为我们要依赖的类的setter函数是setHelloWorld，所以就在它上面加上@Autowired。

最后结果：

![output][output]

### &emsp;纯注释模式

在xml与注释混合的模式下，我们可以看到我们使用@Autowired的流程，首先在xml中配置好资源和所有要用到的实例，然后在依赖的类的setter方法上加上@Autowired就可以了。这样我们就不用管哪个类依赖哪个类，而只用把所有的类都实例化就可以了。

但是有时候我们也会觉得很麻烦，我们还要知道哪些类需要用到，如果不用到的类要删掉，那么我们有没有方法不用管哪些类被使用到呢？那就是使用纯注释的方式。即@Autowired与@Compontent以及@CompontentScan混合。

### &emsp;xml优先原则

即xml的配置是在后置处理器前面处理的。

假如xml文件的bean标签里面有property，而对应的Java文件中里面却去掉了属性的getter/setter，并使用@Autowired注解标注这两个属性会怎么样？答案是Spring会按照xml优先的原则去Java文件中寻找这两个属性的getter/setter，导致的结果就是初始化bean报错。

因为，@Autowired注解要去寻找的是一个Bean，Teacher和 Student的Bean定义都给去掉了，自然就不是一个Bean了，Spring容器找不到也很好理解。那么，如果属性找不到又不想让Spring容器抛出异常，而就是显示null，可以吗？可以，其实异常信息里面也给出了提示，就是将@Autowired注解的required属性设置为false 即可。

此时，找不到teacher、student两个属性，Spring容器不再抛出异常而是认为这两个属性为null。

[output]:data:image/png;base64,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

[]