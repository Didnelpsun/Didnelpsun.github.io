---
layout: post
title:  "Spring基础7"
date:   2020-03-27 10:57:02 +0800
categories: notes spring base
tags: spring 基础 
excerpt: "自动装配"
---

依赖注入和自动装配息息相关。依赖注入的本质就是装配，装配是依赖注入的具体行为。

依赖注入有两种形式：构造器注入和setter注入。也就是我们在xml中写的一堆\<bean></bean>，我们每一个依赖bean就要写一个实例，如果bean太多我们还这样写就会非常麻烦，更何况我们还有把有关联的bean装配起来，一旦bean很多，就不好维护了。

为此Spring使用自动装配解决这个问题，开发人员不用关心具体装配哪个bean的引用，识别工作由Spring来完成，因此一般配有自动监测来和自动装配配合完成。自动装配其实就是将依赖注入"自动化"的一个简化配置的操作。也就是说我们只用实例化我们在应用程序中要使用的实例，而它依赖的实例将由Spring来实例化，如之前一直在使用的HelloWorld类。

自动配置有两大类方式，跟之前的依赖注入和实例化一样，一种是xml，一种是注解。

xml的\<bean>配置中通添加autowire属性实现四种形式的自动装配，byName, byType, constructor, autodetect。byName就是会将与属性的名字一样的bean进行装配。byType就同属性一样类型的bean进行装配。constructor就是通过构造器来将类型与参数相同的bean进行装配。autodetect是constructor与byType的组合，会先进行constructor，如果不成功，再进行byType。

Spring2.5之后提供了注解方式的自动装配。但是要使用这些注解，需要在配置文件中配置<context:annotation-config />。只有加上这一配置，才可以使用注解进行自动装配，默认情况下基于注解的装配是被禁用的。常用的自动装配注解有以下几种：@Autowired，@Resource，@Inject，@Qualifier，@Named。

<span style="color:orange">注意：</span>@Autowired注解是byType类型的，因此会将接口的实现类取代接口，自动装配给控制类。

不过自动装配也有比较大的问题：

当自动装配始终在同一个项目中使用时，它的效果最好。如果通常不使用自动装配，它可能会使开发人员混淆的使用它来连接只有一个或两个bean定义。不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。

限制|描述
:--:|:--
重写的可能性|你可以使用总是重写自动装配的\<constructor-arg>和\<property>设置来指定依赖关系。
原始数据类型|你不能自动装配所谓的简单类型包括基本类型，字符串和类。
混乱的本质|自动装配不如显式装配精确，所以如果可能的话尽可能使用显式装配。

[Spring项目模板文件：spring/spring](https://github.com/Didnelpsun/notes/tree/master/spring/spring)来搭建。

我们要创建一个实例依赖的案例：

```java
//HelloWorld.java
package org.didnelpsun.test;

public class HelloWorld {
    private String words;
    //重写构造方法
    public HelloWorld(){
        System.out.println("HelloWorldClass...");
    }
    public void SetWords(String sayword){
        this.words = sayword;
    }
    //动作方法
    public void SayHello(){
        System.out.println(this.words);
    }
}
```

我们的HelloWorld是简单的类，含有一个私有变量，当构造这个实例会打印字符串。然后使用设置函数初始化实例，这个setter函数会接受一个参数，然后下面的SayHello方法会打印这个方法。

```java
//User.java
//User.java
package org.didnelpsun.test;

public class User {
    private static final String username = "Didnelpsun";
    private HelloWorld helloWorld;
    public void setHelloWorld(HelloWorld helloWorld){
        this.helloWorld = helloWorld;
    }
    public void Say(){
        System.out.println(this.username);
        this.helloWorld.SayHello();
    }
}
```

然后在User类中定义一个私有常量和一个HelloWorld类型的属性，这里的setter函数也要传入一个HelloWorld类型的参数，<span style="color:orange">User依赖HelloWorld</span>。然后有一个Say方法，打印属性并调用HelloWorld实例的方法。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id = "HelloWorld" class="org.didnelpsun.test.HelloWorld">
    </bean>
    <bean id="User" class="org.didnelpsun.test.User">
        <property name="helloWorld" ref="HelloWorld"></property>
    </bean>
</beans>
```

定义两个bean一个是HelloWorld一个是User，如果我们要实现依赖，那么我们要使用ref属性来配置。

```java
//App.java
package org.didnelpsun;
//项目入口
import org.didnelpsun.test.HelloWorld;
import org.didnelpsun.test.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App
{
    //获取私有属性，这个属性是应用文档属性
    private static ApplicationContext welcomeContext;
    public static void main(String args[]){
        welcomeContext = new ClassPathXmlApplicationContext("SpringBeans.xml");
        HelloWorld hello = (HelloWorld) welcomeContext.getBean("HelloWorld");
        User Didenelpsun = (User) welcomeContext.getBean("User");
        hello.SetWords("welcome!");
        Didenelpsun.Say();
    }
}
```

我们也可以不在App.java中实例化这个类。这些是不影响对应的依赖的。如果我们不在xml中配置依赖，也就是删除`<property name="helloWorld" ref="HelloWorld"></property>`，然后再加上`Didenelpsun.setHelloWorld(hello);`也可以配置成功依赖。但是你要注意这是因为在应用程序中配置的，所以这种实例的依赖不是由Spring容器控制的，而是由应用程序控制的，所以你需要关注这些依赖的创建和销毁，当然这是不被建议使用的。

## autowire属性

名称|说明
:--:|:--
no|这是默认的设置，它意味着没有自动装配，你应该使用显式的bean引用来连线。你不用为了连线做特殊的事。在依赖注入章节你已经看到这个了。
byName|由属性名自动装配。Spring容器看到在XML配置文件中bean的自动装配的属性设置为byName。然后尝试匹配，并且将它的属性与在配置文件中被定义为相同名称的beans的属性进行连接。
byType|由属性数据类型自动装配。Spring容器看到在XML配置文件中bean的自动装配的属性设置为byType。然后如果它的类型匹配配置文件中的一个确切的 bean 名称，它将尝试匹配和连接属性的类型。如果存在不止一个这样的bean，则一个致命的异常将会被抛出。
constructor|类似于byType，但该类型适用于构造函数参数类型。如果在容器中没有一个构造函数参数类型的bean，则一个致命错误将会发生。
autodetect|Spring首先尝试通过constructor使用自动装配来连接，如果它不执行，Spring尝试通过byType来自动装配。

可以使用byType或者constructor自动装配模式来连接数组和其他类型的集合。

### &emsp;byName

这种模式由属性名称指定自动装配。Spring容器看作beans，在XML配置文件中beans的auto-wire属性设置为byName。然后，它尝试将它的属性与配置文件中定义为相同名称的beans进行匹配和连接。如果找到匹配项，它将注入这些beans，否则，它将抛出异常。

例如，在配置文件中，如果一个bean定义设置为自动装配byName，并且它包含Age属性（即，它有一个setAge(...) 方法），那么Spring就会查找定义名为Age的bean，并且用它来设置这个属性。你仍然可以使用\<property>标签连接其余的属性。

针对上面的例子，我们应该如何改动呢？注意这个属性值为byName是依赖名字来查找对应的实例的。xml中将参数的ref那行删除，然后改成：`<bean id="User" class="org.didnelpsun.test.User" autowire="byName">`并且一定要注意改变<span style="color:orange">实例名字</span>！`<bean id = "helloWorld" class="org.didnelpsun.test.HelloWorld">`

&emsp;

## @Autowired

通过@Autowired的使用来消除set，get方法。在使用@Autowired之前，我们对一个bean配置起属性时，是用的`<property name="属性名" value=" 属性值"/>`

如果我们两个实例间有调用的关系，如再抽象化HelloWorld类，修改User类：

```java
package org.didnelpsun.test;
import org.springframework.stereotype.Component;
import javax.swing.*;
@Component
public class HelloWorld {
    private String words;
    //重写构造方法
    public HelloWorld(){
        System.out.println("HelloWorldClass...");
    }
    public void SetWords(String sayword){
        this.words = sayword;
    }
    //动作方法
    public void SayHello(){
        System.out.println(this.words);
    }
}
```

这一段代码有什么不同？首先我们将所有的与人相关的动作都抽离出去，HelloWorld类只包含着一个私有变量，一个设置要显示的字符串的方法，从外面获取对应的参数，和一个打印字符串的方法。记得要加@Component，不然会报错：Exception in thread "main" org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'org.didnelpsun.test.User' available。

```java
//User.java
package org.didnelpsun.test;
import org.springframework.beans.factory.annotation.Autowired;

@Component
public class User {
    private static final String username = "Didnelpsun";
    private HelloWorld helloWorld;
    @Autowired
    public void setHelloWorld(HelloWorld helloWorld){
        this.helloWorld = helloWorld;
    }
    public void Say(){
        System.out.println(this.username);
        this.helloWorld.SayHello();
    }
}
```

首先这个User类中设置一个私有常量代表用户名，并且有一个私有变量，使用一个setter方法来设置属性。最后使用Say方法来打印。@Autowired应该写在建立依赖的方法上面。然后我们再思考一下什么叫依赖。HelloWorld类的私有属性的设置是传入一个字符串，而User类的私有属性的设置是传入另一个类，那么后面这一对关系就是属于依赖。

然后我们修改App.java：

```java
//将hello.setWords("nmsl");
//hello.saySomeThing();删除
//导入User类
import org.didnelpsun.test.User;

User Didenelpsun = welcomeContext.getBean(User.class);
hello.SetWords("welcome!");
Didenelpsun.setHelloWorld(hello);
Didenelpsun.Say();
```

![测试输出][testoutput]

那么如何体现自动装配呢？我们可以将App.java的Didenelpsun.setHelloWorld(hello);注释掉，这是不显示将hello实例注入到Didnelpsun的类中，而由Spring的注释注入，我们输出会发现是一样的结果。

我们之前自动注入是写在set函数中，也就是set方法是自动注入对象的，但是实际上我们连这一步都可以不需要。直接在属性上标准，表名这个属性是被自动注入的，而就可以省略后面的setter方法了。然后将App.java中的对应的setter方法也注释掉：

```java
//User.java
package org.didnelpsun.test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class User {
    private static final String username = "Didnelpsun";
    @Autowired
    private HelloWorld helloWorld;
//    public void setHelloWorld(HelloWorld helloWorld){
//        this.helloWorld = helloWorld;
//    }
    public void Say(){
        System.out.println(this.username);
        this.helloWorld.SayHello();
    }
}
```

```java
//App.java
package org.didnelpsun;
//项目入口
import org.didnelpsun.test.HelloWorld;
import org.didnelpsun.test.User;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.stereotype.Component;
@ComponentScan
public class App
{
    //获取私有属性，这个属性是应用文档属性
    private static ApplicationContext welcomeContext;
    public static void main(String args[]){
        welcomeContext = new AnnotationConfigApplicationContext(App.class);
        HelloWorld hello = welcomeContext.getBean(HelloWorld.class);
        User Didenelpsun = welcomeContext.getBean(User.class);
        hello.SetWords("welcome!");
//        Didenelpsun.setHelloWorld(hello);
        Didenelpsun.Say();
    }
}
```

输出是一样的。也就是说使用了这个标准后默认的this的setter和getter方法都不用写了。getter方法就是返回对象。

[testoutput]:data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALgAAABNCAIAAACaDjk6AAAIAUlEQVR4Ae1d3bHjKgz23tkeEldhz2kirmInJeTNNeQtJWRuFT5dOFU4KeG8XUkYLPyDf8nNYuVhY0AS4uOzIGfR8Ovr6+vn5yeSjyDgROAfZ6s0CgI1AkIUocIkBIQok2ASISGKcGASAkKUSTCJ0O83QZCeb+dU9VXeL/eSdetoYlLeHye7gYJRawx93k022Kf8cXUziRJneZ69OEoIx6G4XovKOTZgxwUECOSWoKOpJamLvX2Sae6Zlp74Pd8NbZhAietS8xosN6gNf9L3TKJ8huuvZxUdelypnq+eWr9VyM8UOHGtg2R6xiKPmH77f5f1v5Io7wJnvB+kRVVcGTHK+31c7S+U2Joo9ILVODRReDkwVliHKaElDiNHdoSYUmFz8sDaGMvPuqNeLWwD907P6/V50jumqT7ycYEdHT7SNKqKh3vVrX1qfXGDelxKxHI+shx0NLXMb15cQhQY481ypAaKhgEbmAvBiKXbecWmQe1omrCOBvM8srZDh2McxVESqx0SLkmjWmDmBjNzuVQRWoSQYO+trZFRAcVwY6bGxfZZRE7VaVfLVQMW0/JyuZMMUiY/P2sv0jP1pVcybsXRxMX8PC/5eQwkbz5N1I2TJK6Kb70802MKr9zST5ydUnihTAdV8S8EDugkivTkpOmhKEpVV3fj0Kolmve3ekAwQK45P+kpi5kbTtmJjeCCGVZUlhoyre1AzdGktf18L4koA57Q2x3nt4y3tzHgbROe7e2pWXJwzwrdpcf0VV7KMksP0fMYG2HzQD0YrTrwaZZBI0aWYsQNFTZGhOY2U5DiBDU4wVt4xVh8I5MNqaHoaJrb/3z5DYmCnVsr6nxvOho0S2YLgKXqYX7ZJGlalveojMozPDFdpxaTm/Ros85SwYiUZRhwRv44YGnRipdFyFE1Mlx7uIShL9LJXmwdTdyCh+clS8+AG+V3UeGvgIHm2dVq7WoMxtkfmBLoBCIB7GbjLAOeID/g3/R0qn8vO7Rme6AUsBNcfrAEU6e3wVikzqCODXoqAiauORRoacR+up++Jtw73m658tRWWdbEbWwZUTBORiZqUi86wuBLYxik9sITmlAEFM3WWavoAeiXHaYS+VR+0xs6pqW17W+Hh7hBgf0mrak4xsef/KiVobMLqlo+UuOwQdxsJblWqYp7UZ21wdaahN3paOVo0t7gtx1OecvCJmXilxxcsrCUwgACGy49Az1IdRAICFGCmEb/gxCi+Mc4iB6EKEFMo/9BCFH8YxxED0KUIKbR/yCEKP4xDqIHIUoQ0+h/EEIU/xgH0YMQJYhp9D8IIYp/jIPoQYgSxDT6H4QQxT/GQfSw5TGDGhD6/3X+/+NdoFBkSg5VV9PUsP/Fb58+MDLysB0CM4nSOhOBZwnNeYntnJpiCQ+CgBxRboq8yKxDYCZRqLPmDYZpym9Jiyz1FK7zS7Q/DIF1e5Tyjhk1eFpePoEjsCSicEjU+WJIysDTq+59A2tFCyBPH6iGnKzvozl42gQsbOdadotS7/7rNmgvno1F7Idtm3jRbbDrQJA1a4lC55xVbkyFZ/AH9g00PX05VAQqtJ5Rt+aaOdZua2FpYkYZM4haTZLX0hwqZhApZDwMkhO9g1q39PSa7Kkcy6FqXmw88k7Hg8HKioyyxmA3D21RDlVjkHvYM9RQq1ZHFJpVk3vQD5OS6W9z1G6YUUbpgHBGH+Z7KL3K4Yg0RdFaolA6Z2nySPsh1WkV/a3O2uZNdoqNNTImwy96lR2Ii5KdXjVmZc/tq5YehHpSXq4jh8oB/iYZZZhfRctPpyM7hwqppBcl3IakHfl9VyyJKIDjrUYNQzlsQdXHwlfJ6IDgyqHS6t1v/HPe/IwytDPgomK26Yj/uRDJlJ3rkeHP/lOT5WUUdvwQYAIY8pX90N3x5G459FVLz5aOiK3PRkCI8tnz8zHeBbj0fAy2QTkiESWo6fQ3GCGKP2yDsixECWo6/Q1GiOIP26AsC1GCmk5/gxGi+MM2KMtClKCm099ghCj+sA3KshAlqOn0Nxghij9sg7K85JjBEgDYEQR99GCJmW10yJn/341tBvMmK+8iCkzLBYZERwDeNLThbth5t2EhabEQkKXHgkMKQwgIUYaQkXoLgXlLDx4lVBduMSPWiTK2F5lz1YZ1RpGfUOxvwNrjozhkcEEASNfZY2zXsdANNip5tBGYRxQ8Tq/uaGusYC6GuhuFJtVkeWFpWr4WzSrMcnP6trZuN6BBdmo+zTDpGS4wyPITHKy/4+1vlLA4zY0VmQHN2Hf0NHPpMdtAmI36wg9MmaHqhflamLoMUaG5EUujP3KXF10IRrLqahajNn4RmZBEgzX9e15EoQTSBO/xS5JX+YIpoTtCFPAL87WIaOoCla7b9pRiiQKaudupq0HprfHGF5H1dLO3qplEwdgBaw3c9/gqr2WaJ/EDbiB+leoqK8rE64aGcUx1Il9HknIMtXHKNWU3gHWkTQXbrZg6/gDtJsmE18vzIAIzlx4KKYf0BDyBG9rKV3Y6mbv8FuZroRpd7tX2UWUN994A1hbl5QluwN7nJileHLTx57kRhUIK3NFG10Drm7fu6p3HXysL8rVqtebWSqygJQ0DAyTp8HSzCfHK4cY4HiIxgICcwh8ARqptBOYuPba2lHaDgBBlN1O9bqBClHX47UZbiLKbqV43UCHKOvx2oy1E2c1UrxuoEGUdfrvRFqLsZqrXDVSIsg6/3Wj/B9Dmh5G3K8DjAAAAAElFTkSuQmCC

[]
