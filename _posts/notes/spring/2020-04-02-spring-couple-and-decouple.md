---
layout: post
title: "耦合与解耦"
date: 2020-04-09 23:30:21 +0800
categories: notes spring senior
tags: spring 高级 耦合 解耦
excerpt: "高级入门与耦合概念"
---

通过之前基础的学习我们已经对于Spring框架有了基本的了解，然而之前对于Spring框架的了解不过是其中的一小部分罢了。在前面我们基本上就只讲了Spring的介绍和以Context为主的核心容器（对于其他几个核心容器的用法基本上没有谈到），然后就是如何使用这个容器，基本上就是通过XML进行实例化装配或者使用注释装配，还讲了一点生命周期的概念，最后IoC的部分讲完了再增加一点事务处理的概念。

接下来我们将不从实用的角度而从系统学习的角度进入Spring的进一步探索。

我们如果学过开发软件等相关知识就应该了解到耦合这个概念，对于一个良好的系统，我们当然希望模块内高耦合，模块间低耦合。

耦合就是指程序间的依赖关系，包括：

+ 方法之间的依赖
+ 类之间的依赖
+ 类包之间的依赖

## 类解耦

其实类包也是类依赖的一种，对于类之间的依赖我们之前也已经谈过了，具有多种解决方案，一种是XML实例化依赖对象与被依赖对象，加上dependson、或者ref属性，由Spring去实例化识别与装配，一种是使用@Autowire或者@DependsOn注解去让Spring自动处理，一种是使用@Configuration来写配置类，在配置类里处理对应的依赖关系。但是这里我们将不讨论如何处理依赖，而是将解耦，也就是降低依赖对于程序模块的影响。

解耦就是降低程序间的依赖关系。开发时应该做到，编译时不依赖，运行时少依赖。那么具体如何理解呢？

就比如我们想引用一个Jar包，也就是依赖，如果我们使用的是这种方法来进行依赖：对应的处理方法(new '依赖Jar包类的地址');，那么这个意思就是我们这个处理方法需要一个依赖类，new就是实例化该类，而地址就是对应的Jar包类的路由，正常的流程是首先程序编译，根据这个路由找到这个类包，从中取出这个类，通过new实例化，最后再放到方法中。这就说明我们依赖的引入是在编译的时候产生的。如果它找不到这个类就会编译失败。

而如果我们使用`Class.forName('依赖Jar包类的地址')`的方式来引入，那么它在编译的时候这个地址将是一个字符串，而不会被引入依赖，如果这个依赖类不存在，也只会抛出异常，而不是编译错误。

那么我们如何去解决这个编译时的依赖问题呢？

首先我们应该使用反射来创建对象，而不是使用new关键字和import来引入依赖创建对象。
