---
layout: post
title:  "Spring基础6"
date:   2020-03-25 23:04:22 +0800
categories: notes spring base
tags: spring 基础 @Component @ComponentScan @ComponentScans @Repository @Service @Controller @RestController
excerpt: "注释依赖注入"
---

在Spring中，尽管使用XML配置文件可以实现Bean的装配工作，但如果应用中Bean的数量较多，会导致XML配置文件过于臃肿，从而给维护和升级带来一定的困难。

Java从JDK5.0以后，提供了Annotation（注解）功能，Spring也提供了对Annotation技术的全面支持。Spring3中定义了一系列的Annotation（注解），常用的注解如下：

1. @Component：可以使用此注解描述Spring中的Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。如果不好分类就用这个注解。一般是针对普通的POJO。
2. @Repository：用于将数据访问层（DAO层）的类标识为Spring中的Bean，其功能与@Component相同。
3. @Service：通常作用在业务层（Service层），注入DAO层，用于将业务层的类标识为Spring中的Bean，其功能与@Component相同。
4. @Controller：通常作用在控制层（如Struts2的Action），用于将控制层的类标识为Spring中的Bean，注入服务，其功能与@Component相同。
5. 其他的相关配置在后面一节会谈到。

我们这里会讲到[三层架构]({% post_url notes/spring/2020-01-29-spring1 %})，我们暂时只会用到前面三种注释，对于三层结构的注释会在后面使用。

## @Component、@ComponentScan和@ComponentScans

### &emsp;@Component

我们之前在[基本容器与实例注入的注释]({% post_url notes/spring/2020-03-19-spring2 %})已经用过了@Component和@ComponentScan来配置，这里我们并不会着重谈到。

在xml文件中写入`<context:component-scan base-package="扫描的包名">`引入Component的扫描组件。

相当于配置文件中applicationContext.xml中的一句：\<bean id="XXX" class="XXXXX"></bean>，即将这个类实例化变成一个实例放入实例池中被容器操纵。

同时我们也可以从此知道，我们在接口上添加这个注解是没有用的，因为接口没有构造方法也不可能被实例化。

对于@Controller，@Service，@Repository注解，查看其源码你会发现，他们中有一个共同的注解@Component，没错@ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository。它们并没有本质的区别，只是为了标注不同的功能罢了。

### &emsp;@ComponentScan

@ComponentScan的作用就是根据定义的扫描路径，把符合扫描规则的类装配到spring容器中，如我们在App.java就是在最上面加上这个注释，表明在这里使用扫描器，来查看加载类。与ComponentScan注解相对应的XML配置就是\<context:component-scan/>

如<span style="color:aqua">格式：</span>`@ComponentScan(value="要扫描的包名")`

#### &emsp;&emsp;源码

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan {
    /**
     * 对应的包扫描路径 可以是单个路径，也可以是扫描的路径数组
     * @return
     */
    @AliasFor("basePackages")
    String[] value() default {};
    /**
     * 和value一样是对应的包扫描路径 可以是单个路径，也可以是扫描的路径数组
     * @return
     */
    @AliasFor("value")
    String[] basePackages() default {};
    /**
     * 指定具体的扫描的类
     * @return
     */
    Class<?>[] basePackageClasses() default {};
    /**
     * 对应的bean名称的生成器 默认的是BeanNameGenerator
     * @return
     */
    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;
    /**
     * 处理检测到的bean的scope范围
     */
    Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;
    /**
     * 是否为检测到的组件生成代理
     * Indicates whether proxies should be generated for detected components, which may be
     * necessary when using scopes in a proxy-style fashion.
     * <p>The default is defer to the default behavior of the component scanner used to
     * execute the actual scan.
     * <p>Note that setting this attribute overrides any value set for {@link #scopeResolver}.
     * @see ClassPathBeanDefinitionScanner#setScopedProxyMode(ScopedProxyMode)
     */
    ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;
    /**
     * 控制符合组件检测条件的类文件   默认是包扫描下的  **/*.class
     * @return
     */
    String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;
    /**
     * 是否对带有@Component @Repository @Service @Controller注解的类开启检测,默认是开启的
     * @return
     */
    boolean useDefaultFilters() default true;
    /**
     * 指定某些定义Filter满足条件的组件 FilterType有5种类型如：
     *                                  ANNOTATION, 注解类型 默认
                                        ASSIGNABLE_TYPE,指定固定类
                                        ASPECTJ， ASPECTJ类型
                                        REGEX,正则表达式
                                        CUSTOM,自定义类型
     * @return
     */
    Filter[] includeFilters() default {};
    /**
     * 排除某些过来器扫描到的类
     * @return
     */
    Filter[] excludeFilters() default {};
    /**
     * 扫描到的类是都开启懒加载 ，默认是不开启的
     * @return
     */
    boolean lazyInit() default false;
}
```

#### &emsp;&emsp;源码参数

+ basePackages与value:  用于指定包的路径，进行扫描
+ basePackageClasses: 用于指定某个类的包的路径进行扫描
+ nameGenerator: bean的名称的生成器
+ useDefaultFilters: 是否开启对@Component，@Repository，@Service，@Controller的类进行检测
+ includeFilters: 包含的过滤条件
1. FilterType.ANNOTATION：按照注解过滤
2. FilterType.ASSIGNABLE_TYPE：按照给定的类型
3. FilterType.ASPECTJ：使用ASPECTJ表达式
4. FilterType.REGEX：正则
5. FilterType.CUSTOM：自定义规则
+ excludeFilters: 排除的过滤条件，用法和includeFilters一样

如：

```java
@ComponentScan(value = "com.xhx.spring.service",
        useDefaultFilters = true,
        basePackageClasses = HelloController.class
)
```

#### &emsp;&emsp;常用的方法

+ 自定扫描路径下边带有@Controller，@Service，@Repository，@Component注解加入spring容器
+ 通过includeFilters加入扫描路径下没有以上注解的类加入spring容器
+ 通过excludeFilters过滤出不用加入spring容器的类
+ 自定义增加了@Component注解的注解方式

#### &emsp;&emsp;常用参数

+ value：指定要扫描的package；
+ includeFilters=Filter[]：指定只包含的组件
+ excludeFilters=Filter[]：指定需要排除的组件；
+ useDefaultFilters=true/false：指定是否需要使用Spring默认的扫描规则：被@Component, @Repository, @Service, @Controller或者已经声明过@Component自定义注解标记的组件；

#### &emsp;&emsp;详细的例子

1. 扫描指定类文件：`@ComponentScan(basePackageClasses = Person.class)`
2. 扫描指定包，使用默认扫描规则，即被@Component, @Repository, @Service, @Controller或者已经声明过@Component自定义注解标记的组件：`@ComponentScan(value = "com.yibai")`
3. 扫描指定包，加载被@Component注解标记的组件和默认规则的扫描（因为useDefaultFilters默认为true）：`@ComponentScan(value = "com.yibai", includeFilters = { @Filter(type = FilterType.ANNOTATION, value = Component.class) })`
4. 扫描指定包，只加载Person类型的组件：`@ComponentScan(value = "com.yibai", includeFilters = { @Filter(type = FilterType.ASSIGNABLE_TYPE, value = Person.class) }, useDefaultFilters = false)`
5. 扫描指定包，过滤掉被@Component标记的组：`@ComponentScan(value = "com.yibai", excludeFilters = { @Filter(type = FilterType.ANNOTATION, value = Component.class) })`
6. 扫描指定包，自定义过滤规则：`@ComponentScan(value = "com.yibai", includeFilters = { @Filter(type = FilterType.CUSTOM, value = ColorBeanLoadFilter.class) }, useDefaultFilters = true)`

### &emsp;@ComponentScans

可以一次声明多个@ComponentScan。

#### &emsp;&emsp;源码

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)  //指定ComponentScan可以被ComponentScans作为数组使用
public @interface ComponentScan {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
public @interface ComponentScans {
    ComponentScan[] value();

}
```

#### &emsp;&emsp;具体例子

```java
@ComponentScans(value = { @ComponentScan(value = "com.yibai.spring.annotation"),
        @ComponentScan(value = "com.yibai.spring.annotation", includeFilters = {
                @Filter(type = FilterType.CUSTOM, value = ColorBeanLoadFilter.class) }) })
public class MainConfig {

    @Bean(name = "pers", initMethod = "init", destroyMethod = "destory")
    public Person person() {
        return new Person();
    }
}
```

&emsp;

## @Repository

@Repository 会被作为持久层操作（数据库）的bean来使用@Repository注解修饰哪个类，则表明这个类具有对对象进行CRUD（增删改查）的功能，而且@Repository是@Component注解的一个派生品，所以被@Repository注解的类可以自动的被@ComponentScan 通过路径扫描给找到。（这也在一定程度上解释了，为什么被@Repository注解的类也能@Autowired，这个注释后面会提到）

为什么 @Repository 只能标注在 DAO 类上呢？这是因为该注解的作用不只是将类识别为Bean，同时它还能将所标注的类中抛出的数据访问异常封装为 Spring 的数据访问异常类型。 Spring本身提供了一个丰富的并且是与具体的数据访问技术无关的数据访问异常结构，用于封装不同的持久层框架抛出的异常，使得异常独立于底层的框架。

实际的应用将在后面讲到。

&emsp;

## @Service

@Service标注业务层组件，标注将这个类交给Spring容器管理，spring容器要为他创建对象。

如果只用@autowired注解来注入bean，不在业务层使用@Service
启动服务会报错：Field xxxService in xx.xxx.controller.xxxController required a bean of type 'xx.xxx.utils.xxxService' that could not be found。

对于实际的应用将在后面讲到。

&emsp;

## @Controller

@Controller 注解的bean会被spring-mvc框架所使用。

@Controller用于标记在一个类上，使用它标记的类就是一个SpringMvc Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。
@Controller只是定义了一个控制器类，而使用@RequestMapping注解的方法才是处理请求的处理器。
@Controller标记在一个类上还不能真正意义上说它就是SpringMvc的控制器，应为这个时候Spring还不认识它，这个时候需要把这个控制器交给Spring来管理。有两种方式可以管理：

```xml
<!--基于注解的装配-->
<!--方式一-->
<bean class="com.HelloWorld"/>
<!--方式二-->
<!--路径写到controller的上一层-->
<context:component-scan base-package="com"/>
```

```java
package com;
@Controller
public class HelloWorld{

    @RequestMapping(value="/showRegUser")
    public String printHello() {
        return "hello";
    }

    @Autowried
    private IocSerevce service;
    public void add(){
        service.add();
    }
}
```

### &emsp;@Controller和@RestController的区别

1. 如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，或者html，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return里的内容。
2. 如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。
3. 例如使用@Controller注解，在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面若返回json等内容到页面，则需要加@ResponseBody注解
4. @RestController注解，相当于@Controller+@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面

对于实际的应用将在后面讲到。
