---
layout: post
title:  "Vue面试题库"
date:   2020-06-28 20:20:21 +0800
categories: share
tags: vue 面试 题库
excerpt: "Vue面试题库搜集"
---

## 基本概念

### &emsp;什么是MVVM与MVC有什么区别

### &emsp;怎样理解单向数据流

这个概念出现在组件通信。父组件是通过prop把数据传递到子组件的，但是这个prop只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过$emit派发一个自定义事件，父组件接收到后，由父组件修改。

一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案：

在子组件的data中拷贝一份prop，data是可以修改的，但prop不能：

```vue
export default {
  props: {
    value: String
  },
  data () {
    return {
      currentValue: this.value
    }
  }
}
```

如果是对 prop 值的转换，可以使用计算属性：

```vue
export default {
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase();
    }
  }
}
```

&emsp;

## 具体细节

### &emsp;v-show与v-if区别

v-show是css切换，v-if是完整的销毁和重新创建。

频繁切换时用v-show，运行时较少改变时用v-if

### &emsp;动态绑定class的方法

+ 对象方法：`v-bind:class="{'orange': isRipe, 'green': isNotRipe}"`
+ 数组方法：`v-bind:class="[class1, class2]"`
+ 行内：`v-bind:style="{color: color, fontSize: fontSize+'px' }"`

### &emsp;计算属性和watch的区别

计算属性的目的是计算，能处理比较复杂的运算，更强调对应依赖的变化来计算，且不能计算在data中定义的值。基于响应式依赖进行缓存的。主要是因为多个相关属性的变化会影响该属性的变化。

监听属性的目的是监听，目标是监听变量的变化，它的变化主要针对异步操作。主要是因为被监听的属性变化将影响多个属性的变化。

#### &emsp;&emsp;computed是一个对象时，它有哪些选项

有get和set两个选项来设置和去除数据。

#### &emsp;&emsp;computed和methods有什么区别

methods是一个方法，它可以接受参数，而computed不能，computed是可以缓存的，methods不会。computed是响应式缓存，对应数据的变化，而methods是非相应的，只能手动调用。所以对于大量数据运算，computed要优于methods，因为它是必要才会重新计算，而不是如methods调用就要计算。

#### &emsp;&emsp;computed是否能依赖其它组件的数据

computed可以依赖其他computed，甚至是其他组件的data。

#### &emsp;&emsp;watch是一个对象时，它有哪些选项

+ watch配置
+ handler
+ deep是否深度
+ immeditate是否立即执行

### &emsp;组件中data为什么为函数

在使用new Vue()来构建实例时data可以为一个对象，是它不被复用，所以这样就不会被引用，作用域也不会混乱，而组件则不同，因为组件用来复用，所以JS对象都是引用的关系，如果是直接一个返回对象，那么所有地方都会使用到同一个实例，作用域就会被污染，当使用函数返回一个new对象时是新建一个对象，所以复用都是不同实例化的对象，就不会作用域污染。



### &emsp;自定义组件的语法糖v-model是怎样实现的

v-model是实现双向绑定，但是本质是语法糖，是多个原有处理方法组合起来方便使用的工具，基层实现是v-bind加v-on:input：

```vue
<input v-model="Didnelpsun">
<!--等价于-->
<input v-bind:value="Didnelpsun" v-on:input="Didnelpsun=$event.target.value">
```

### &emsp;生命周期

+ 创建前后 beforeCreate/created：在beforeCreate 阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象有了，el还没有。
+ 载入前后 beforeMount/mounted：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前未虚拟的DOM节点，data尚未替换。在mounted阶段，vue实例挂载完成，data成功渲染。
+ 更新前后 beforeUpdate/updated：当data变化时，会触发beforeUpdate和updated方法。这两个不常用，不推荐使用。
+ 销毁前后beforeDestory/destoryed：beforeDestory是在vue实例销毁前触发，一般在这里要通过removeEventListener解除手动绑定的事件。实例销毁后，触发的destroyed。

### &emsp;组件通信

父子 props/event children/parent ref provide/inject
兄弟 bus vuex
跨级 bus vuex provide.inject

### &emsp;路由跳转

+ <router-link to='home'> router-link标签会渲染为<a>标签，咋填template中的跳转都是这种；
+ 另一种是编程是导航 也就是通过js跳转 比如 router.push('/home')

### &emsp;vue-router有哪几种导航钩子

### &emsp;vuex

### &emsp;this.$nextTick()

### &emsp;vue的原理

### &emsp;理解Vue中的Render渲染函数

### &emsp;slot插槽

&emsp;

## 底层原理

### &emsp;Vue.js响应式原理

[原理解释](https://cn.vuejs.org/v2/guide/reactivity.html)

shim指可以将新的API引入到旧的环境中，而且仅靠就环境中已有的手段实现。

